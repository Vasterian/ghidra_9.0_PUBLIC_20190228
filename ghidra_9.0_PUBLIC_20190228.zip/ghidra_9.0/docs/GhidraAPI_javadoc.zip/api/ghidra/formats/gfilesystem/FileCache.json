{"implements":[],"javadoc":"File caching implementation.\n <p>\n Caches files based on a hash of the contents of the file.<br>\n Files are retrieved using the hash string.<p>\n Cached files are stored in a file with a name that is the hex encoded value of the hash.\n Cached files are organized into a nested directory structure to prevent\n overwhelming a single directory with thousands of files.\n <p>\n Nested directory structure is based on the file's name:\n   File: AABBCCDDEEFF...\n   Directory (2 level nesting): AA\/BB\/AABBCCDDEEFF...\n <p>\n Cache size is not bounded.\n <p>\n Cache maint is done during startup if interval since last maint has been exceeded\n <p>\n No file data is maintained in memory.\n <p>\n No file is moved or removed from the cache after being added (except during startup)\n as there is no use count or reference tracking of the files.","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"Creates a new {@link FileCache} instance where files are stored under the specified\n {@code cacheDir}\n <p>\n@param cacheDir where to store the files\n@throws IOException if there was a problem creating subdirectories under cacheDir or\n when pruning expired files.","static":false,"name":"<init>","comment":"Creates a new FileCache instance where files are stored under the specified\n \n ","params":[{"type_long":"java.io.File","name":"cacheDir","comment":"where to store the files","type_short":"File"}],"throws":[{"type_long":"java.io.IOException","comment":"if there was a problem creating subdirectories under cacheDir or\n when pruning expired files.","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Deletes all stored files from this file cache that are under a \"NN\" two hex digit\n nesting dir.\n <p>\n Will cause other processes which are accessing or updating the cache to error.","static":false,"name":"purge","comment":"Deletes all stored files from this file cache that are under a \"NN\" two hex digit\n nesting dir.\n \n Will cause other processes which are accessing or updating the cache to error.","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Adds a {@link File} to the cache, returning a {@link FileCacheEntry}.\n@param f {@link File} to add to cache.\n@param monitor {@link TaskMonitor} to monitor for cancel and to update progress.\n@return {@link FileCacheEntry} with new File and md5.\n@throws IOException if error\n@throws CancelledException if canceled","static":false,"name":"addFile","comment":"Adds a File to the cache, returning a FileCacheEntry.","params":[{"type_long":"java.io.File","name":"f","comment":"File to add to cache.","type_short":"File"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"TaskMonitor to monitor for cancel and to update progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"java.io.IOException","comment":"if error","type_short":"IOException"},{"type_long":"ghidra.util.exception.CancelledException","comment":"if canceled","type_short":"CancelledException"}],"return":{"type_long":"ghidra.formats.gfilesystem.FileCacheEntry","comment":"FileCacheEntry with new File and md5.","type_short":"FileCacheEntry"}},{"javadoc":"Returns a {@link FileCacheEntry} for the matching file, based on its MD5, or\n NULL if there is no matching file.\n <p>\n Tweaks the file's last modified time to implement a LRU.\n@param md5 md5 string.\n@return {@link FileCacheEntry} with a File and it's md5 string or {@code null} if no\n matching file exists in cache.","static":false,"name":"getFile","comment":"Returns a FileCacheEntry for the matching file, based on its MD5, or\n NULL if there is no matching file.\n \n Tweaks the file's last modified time to implement a LRU.","params":[{"type_long":"java.lang.String","name":"md5","comment":"md5 string.","type_short":"String"}],"throws":[],"return":{"type_long":"ghidra.formats.gfilesystem.FileCacheEntry","comment":"FileCacheEntry with a File and it's md5 string or  if no\n matching file exists in cache.","type_short":"FileCacheEntry"}},{"javadoc":"Adds a contents of a stream to the cache, returning the md5 identifier of the stream.\n <p>\n The stream is copied into a temp file in the cacheDir\/new directory while its md5\n is calculated.  The temp file is then moved into its final location\n based on the md5 of the stream: AA\/BB\/CC\/AABBCCDDEEFF....\n <p>\n The monitor progress is updated with the number of bytes that are being copied.  No\n message or maximum is set.\n <p>\n@param is {@link InputStream} to add to the cache.  Not closed when done.\n@param monitor {@link TaskMonitor} that will be checked for canceling and updating progress.\n@return {@link FileCacheEntry} with file info and md5, never null.\n@throws IOException if error\n@throws CancelledException if canceled","static":false,"name":"addStream","comment":"Adds a contents of a stream to the cache, returning the md5 identifier of the stream.\n \n The stream is copied into a temp file in the cacheDir\/new directory while its md5\n is calculated.  The temp file is then moved into its final location\n based on the md5 of the stream: AA\/BB\/CC\/AABBCCDDEEFF....\n \n The monitor progress is updated with the number of bytes that are being copied.  No\n message or maximum is set.\n ","params":[{"type_long":"java.io.InputStream","name":"is","comment":"InputStream to add to the cache.  Not closed when done.","type_short":"InputStream"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"TaskMonitor that will be checked for canceling and updating progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"java.io.IOException","comment":"if error","type_short":"IOException"},{"type_long":"ghidra.util.exception.CancelledException","comment":"if canceled","type_short":"CancelledException"}],"return":{"type_long":"ghidra.formats.gfilesystem.FileCacheEntry","comment":"FileCacheEntry with file info and md5, never null.","type_short":"FileCacheEntry"}},{"javadoc":"Adds a file to the cache, using a 'pusher' strategy where the producer is given a\n {@link OutputStream} to write to.\n <p>\n Unbeknownst to the producer, but knownst to us, the outputstream is really a\n {@link HashingOutputStream} that will allow us to get the MD5 hash when the producer\n is finished pushing.\n@param pusher functional callback that will accept an {@link OutputStream} and write\n to it.\n <pre> (os) -> { os.write(.....); }<\/pre>\n@param monitor {@link TaskMonitor} that will be checked for cancel and updated with\n file io progress.\n@return a new {@link FileCacheEntry} with the newly added cache file's File and MD5,\n never null.\n@throws IOException if an IO error\n@throws CancelledException if the user cancels","static":false,"name":"pushStream","comment":"Adds a file to the cache, using a 'pusher' strategy where the producer is given a\n OutputStream to write to.\n \n Unbeknownst to the producer, but knownst to us, the outputstream is really a\n HashingOutputStream that will allow us to get the MD5 hash when the producer\n is finished pushing.","params":[{"type_long":"ghidra.formats.gfilesystem.DerivedFilePushProducer","name":"pusher","comment":"functional callback that will accept an OutputStream and write\n to it.\n  (os) - { os.write(.....); }","type_short":"DerivedFilePushProducer"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"TaskMonitor that will be checked for cancel and updated with\n file io progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"java.io.IOException","comment":"if an IO error","type_short":"IOException"},{"type_long":"ghidra.util.exception.CancelledException","comment":"if the user cancels","type_short":"CancelledException"}],"return":{"type_long":"ghidra.formats.gfilesystem.FileCacheEntry","comment":"a new FileCacheEntry with the newly added cache file's File and MD5,\n never null.","type_short":"FileCacheEntry"}},{"javadoc":"","static":false,"name":"toString","comment":"","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"Number of files added to this cache.\n@return Number of files added to this cache","static":false,"name":"getFileAddCount","comment":"Number of files added to this cache.","params":[],"throws":[],"return":{"type_long":"int","comment":"Number of files added to this cache","type_short":"int"}},{"javadoc":"Number of times a file-add was a no-op and the contents were already present\n in the cache.\n@return Number of times a file-add was a no-op and the contents were already present\n in the cache.","static":false,"name":"getFileReUseCount","comment":"Number of times a file-add was a no-op and the contents were already present\n in the cache.","params":[],"throws":[],"return":{"type_long":"int","comment":"Number of times a file-add was a no-op and the contents were already present\n in the cache.","type_short":"int"}},{"javadoc":"Estimate of the number of bytes in the cache.\n@return estimate of the number of bytes in the cache - could be very wrong","static":false,"name":"getStorageEstimateBytes","comment":"Estimate of the number of bytes in the cache.","params":[],"throws":[],"return":{"type_long":"long","comment":"estimate of the number of bytes in the cache - could be very wrong","type_short":"long"}},{"javadoc":"How old (in milliseconds) files must be before being aged-off during cache maintenance.\n@return Max cache file age in milliseconds.","static":false,"name":"getMaxFileAgeMS","comment":"How old (in milliseconds) files must be before being aged-off during cache maintenance.","params":[],"throws":[],"return":{"type_long":"long","comment":"Max cache file age in milliseconds.","type_short":"long"}}],"name":"FileCache","comment":"File caching implementation.\n \n Caches files based on a hash of the contents of the file.\n Files are retrieved using the hash string.\n Cached files are stored in a file with a name that is the hex encoded value of the hash.\n Cached files are organized into a nested directory structure to prevent\n overwhelming a single directory with thousands of files.\n \n Nested directory structure is based on the file's name:\n   File: AABBCCDDEEFF...\n   Directory (2 level nesting): AA\/BB\/AABBCCDDEEFF...\n \n Cache size is not bounded.\n \n Cache maint is done during startup if interval since last maint has been exceeded\n \n No file data is maintained in memory.\n \n No file is moved or removed from the cache after being added (except during startup)\n as there is no use count or reference tracking of the files.","fields":[{"type_long":"int","javadoc":"","static":true,"name":"MD5_HEXSTR_LEN","comment":"","type_short":"int","constant_value":"32"}]}
