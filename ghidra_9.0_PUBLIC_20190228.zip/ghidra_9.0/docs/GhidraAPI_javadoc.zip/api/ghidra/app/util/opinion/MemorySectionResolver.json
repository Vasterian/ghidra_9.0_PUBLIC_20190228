{"implements":[],"javadoc":"","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"","static":false,"name":"<init>","comment":"","params":[{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"","type_short":"Program"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Add initialized memory \"section\" based upon a specified data source fileOffset.\n The last \"section\" defined will take precedence when resolving conflicts. Sections identified \n as loaded will take precedence over those that are non-loaded.\n placed into memory\n@param key the loadable section key which corresponds to this memory \"section\"\n@param fileOffset data source file offset.  It is assumed that all initialized\n \"sections\" draw from a single data source.\n@param length number of bytes within \"section\"\n@param startAddress desired physical start address of \"section\"\n@param sectionName name of \"section\"\n@param isReadable true if \"section\" has read privilege\n@param isWritable true if \"section\" has write privilege\n@param isExecutable true if \"section\" has execute privilege\n@param comment section comment (used as basis for block comment)\n@param isFragmentationOK if true this memory section may be fragmented due to\n@param isLoadedSection if true this memory section will take precedence over non-loaded sections\n conflict\/overlap with other memory sections of higher precedence.\n@throws AddressOverflowException","static":false,"name":"addInitializedMemorySection","comment":"Add initialized memory \"section\" based upon a specified data source fileOffset.\n The last \"section\" defined will take precedence when resolving conflicts. Sections identified \n as loaded will take precedence over those that are non-loaded.\n placed into memory","params":[{"type_long":"ghidra.app.util.bin.format.MemoryLoadable","name":"key","comment":"the loadable section key which corresponds to this memory \"section\"","type_short":"MemoryLoadable"},{"type_long":"long","name":"fileOffset","comment":"data source file offset.  It is assumed that all initialized\n \"sections\" draw from a single data source.","type_short":"long"},{"type_long":"long","name":"numberOfBytes","comment":"","type_short":"long"},{"type_long":"ghidra.program.model.address.Address","name":"startAddress","comment":"desired physical start address of \"section\"","type_short":"Address"},{"type_long":"java.lang.String","name":"sectionName","comment":"name of \"section\"","type_short":"String"},{"type_long":"boolean","name":"isReadable","comment":"true if \"section\" has read privilege","type_short":"boolean"},{"type_long":"boolean","name":"isWritable","comment":"true if \"section\" has write privilege","type_short":"boolean"},{"type_long":"boolean","name":"isExecutable","comment":"true if \"section\" has execute privilege","type_short":"boolean"},{"type_long":"java.lang.String","name":"comment","comment":"section comment (used as basis for block comment)","type_short":"String"},{"type_long":"boolean","name":"isFragmentationOK","comment":"if true this memory section may be fragmented due to","type_short":"boolean"},{"type_long":"boolean","name":"isLoadedSection","comment":"if true this memory section will take precedence over non-loaded sections\n conflict\/overlap with other memory sections of higher precedence.","type_short":"boolean"}],"throws":[{"type_long":"ghidra.program.model.address.AddressOverflowException","comment":"","type_short":"AddressOverflowException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Add uninitialized memory \"section\".\n The last \"section\" defined will take precedence when resolving conflicts.\n@param key the loadable section key which corresponds to this memory \"section\"\n@param length number of bytes within \"section\"\n@param startAddress desired physical start address of \"section\"\n@param sectionName name of \"section\"\n@param isReadable true if \"section\" has read privilege\n@param isWritable true if \"section\" has write privilege\n@param isExecutable true if \"section\" has execute privilege\n@param comment section comment (used as basis for block comment)\n@param isFragmentationOK if true this memory section may be fragmented due to \n conflict\/overlap with other memory sections of higher precedence.\n@throws AddressOverflowException","static":false,"name":"addUninitializedMemorySection","comment":"Add uninitialized memory \"section\".\n The last \"section\" defined will take precedence when resolving conflicts.","params":[{"type_long":"ghidra.app.util.bin.format.MemoryLoadable","name":"key","comment":"the loadable section key which corresponds to this memory \"section\"","type_short":"MemoryLoadable"},{"type_long":"long","name":"numberOfBytes","comment":"","type_short":"long"},{"type_long":"ghidra.program.model.address.Address","name":"startAddress","comment":"desired physical start address of \"section\"","type_short":"Address"},{"type_long":"java.lang.String","name":"sectionName","comment":"name of \"section\"","type_short":"String"},{"type_long":"boolean","name":"isReadable","comment":"true if \"section\" has read privilege","type_short":"boolean"},{"type_long":"boolean","name":"isWritable","comment":"true if \"section\" has write privilege","type_short":"boolean"},{"type_long":"boolean","name":"isExecutable","comment":"true if \"section\" has execute privilege","type_short":"boolean"},{"type_long":"java.lang.String","name":"comment","comment":"section comment (used as basis for block comment)","type_short":"String"},{"type_long":"boolean","name":"isFragmentationOK","comment":"if true this memory section may be fragmented due to \n conflict\/overlap with other memory sections of higher precedence.","type_short":"boolean"}],"throws":[{"type_long":"ghidra.program.model.address.AddressOverflowException","comment":"","type_short":"AddressOverflowException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Perform final resolve of all defined memory \"sections\" to establish final memory mappings.\n This method will resolve all conflicts and create memory blocks within the associated program.\n@param monitor\n@throws CancelledException","static":false,"name":"resolve","comment":"Perform final resolve of all defined memory \"sections\" to establish final memory mappings.\n This method will resolve all conflicts and create memory blocks within the associated program.","params":[{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Get program memory object\n@return program memory","static":false,"name":"getMemory","comment":"Get program memory object","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.mem.Memory","comment":"program memory","type_short":"Memory"}},{"javadoc":"Get program object\n@return program","static":false,"name":"getProgram","comment":"Get program object","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Program","comment":"program","type_short":"Program"}}],"name":"MemorySectionResolver","comment":"","fields":[]}
