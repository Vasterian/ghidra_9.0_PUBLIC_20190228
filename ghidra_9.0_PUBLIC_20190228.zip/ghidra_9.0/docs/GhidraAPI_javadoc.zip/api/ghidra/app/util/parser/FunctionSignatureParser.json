{"implements":[],"javadoc":"Class for parsing function signatures. This class attempts to be much more flexible than\n a full parser that requires correct C or C++ syntax.  To achieve this, it scans the original\n function signature (if present) for names that would cause parse problems (parens, commas, and\n spaces).  If it finds any problem names, it looks for those strings in the text to be parsed and\n if it finds them, it replaces them with substitutes that parse easily.  Then, after parsing, those\n replacement strings are then restored to their original values.\n <P>\n Some examples of valid c++ that would fail due to the current limitations:\n <P>\n void foo(myclass<int, float> x) - fails due to comma in x's data type name\n int operator()(int x) - fails due to parens in function name\n unsigned int bar(float y) - fails due to space in return type name\n <P>\n Note: you can edit signatures that already have these features as long as your modifications\n don't affect the pieces containing parens, commas or spaces in their name.","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"Constructs a SignatureParser for a program.\n@param program the program whose datatype manager is used to resolve datatype names.\n@param service the DataTypeManagerService to use for resolving datatypes that can't be\n found in the given program. Can be null to utilize program based types only.","static":false,"name":"<init>","comment":"Constructs a SignatureParser for a program.","params":[{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"the program whose datatype manager is used to resolve datatype names.","type_short":"Program"},{"type_long":"ghidra.app.services.DataTypeManagerService","name":"service","comment":"the DataTypeManagerService to use for resolving datatypes that can't be\n found in the given program. Can be null to utilize program based types only.","type_short":"DataTypeManagerService"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Parse the given function signature text into a FunctionDefinitionDataType.\n@param originalSignature the function signature before editing.  This may be null\n if the user is entering a new signature instead of editing an existing one.\n@param signatureText the text to be parsed into a function signature.\n@return the FunctionDefinitionDataType resulting from parsing.\n@throws ParseException if the text could not be parsed.","static":false,"name":"parse","comment":"Parse the given function signature text into a FunctionDefinitionDataType.","params":[{"type_long":"ghidra.program.model.listing.FunctionSignature","name":"originalSignature","comment":"the function signature before editing.  This may be null\n if the user is entering a new signature instead of editing an existing one.","type_short":"FunctionSignature"},{"type_long":"java.lang.String","name":"signatureText","comment":"the text to be parsed into a function signature.","type_short":"String"}],"throws":[{"type_long":"ghidra.app.util.cparser.C.ParseException","comment":"if the text could not be parsed.","type_short":"ParseException"}],"return":{"type_long":"ghidra.program.model.data.FunctionDefinitionDataType","comment":"the FunctionDefinitionDataType resulting from parsing.","type_short":"FunctionDefinitionDataType"}}],"name":"FunctionSignatureParser","comment":"Class for parsing function signatures. This class attempts to be much more flexible than\n a full parser that requires correct C or C++ syntax.  To achieve this, it scans the original\n function signature (if present) for names that would cause parse problems (parens, commas, and\n spaces).  If it finds any problem names, it looks for those strings in the text to be parsed and\n if it finds them, it replaces them with substitutes that parse easily.  Then, after parsing, those\n replacement strings are then restored to their original values.\n \n Some examples of valid c++ that would fail due to the current limitations:\n \n void foo(myclassint, float x) - fails due to comma in x's data type name\n int operator()(int x) - fails due to parens in function name\n unsigned int bar(float y) - fails due to space in return type name\n \n Note: you can edit signatures that already have these features as long as your modifications\n don't affect the pieces containing parens, commas or spaces in their name.","fields":[]}
