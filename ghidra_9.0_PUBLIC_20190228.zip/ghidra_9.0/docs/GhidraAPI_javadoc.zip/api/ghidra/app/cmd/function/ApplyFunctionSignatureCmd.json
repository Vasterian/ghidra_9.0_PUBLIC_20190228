{"implements":[],"javadoc":"Command to create apply a function signature at an address.","static":false,"extends":"ghidra.framework.cmd.BackgroundCommand","methods":[{"javadoc":"Constructs a new command for creating a function.\n@param entry entry point address for the function to be created.\n@param signature function signature to apply\n@param source the source of this function signature","static":false,"name":"<init>","comment":"Constructs a new command for creating a function.","params":[{"type_long":"ghidra.program.model.address.Address","name":"entry","comment":"entry point address for the function to be created.","type_short":"Address"},{"type_long":"ghidra.program.model.listing.FunctionSignature","name":"signature","comment":"function signature to apply","type_short":"FunctionSignature"},{"type_long":"ghidra.program.model.symbol.SourceType","name":"source","comment":"the source of this function signature","type_short":"SourceType"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Constructs a new command for creating a function.\n@param entry entry point address for the function to be created.\n@param signature function signature to apply\n@param source the source of this function signature\n@param preserveCallingConvention if true the function calling convention will not be changed\n@param setName true if name of the function should be set to the name\n of the signature","static":false,"name":"<init>","comment":"Constructs a new command for creating a function.","params":[{"type_long":"ghidra.program.model.address.Address","name":"entry","comment":"entry point address for the function to be created.","type_short":"Address"},{"type_long":"ghidra.program.model.listing.FunctionSignature","name":"signature","comment":"function signature to apply","type_short":"FunctionSignature"},{"type_long":"ghidra.program.model.symbol.SourceType","name":"source","comment":"the source of this function signature","type_short":"SourceType"},{"type_long":"boolean","name":"preserveCallingConvention","comment":"if true the function calling convention will not be changed","type_short":"boolean"},{"type_long":"boolean","name":"setName","comment":"true if name of the function should be set to the name\n of the signature","type_short":"boolean"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"@see ghidra.framework.cmd.BackgroundCommand#applyTo(ghidra.framework.model.DomainObject, ghidra.util.task.TaskMonitor)","static":false,"name":"applyTo","comment":"","params":[{"type_long":"ghidra.framework.model.DomainObject","name":"obj","comment":"","type_short":"DomainObject"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"The C language assumes array datatypes are passed simply as pointers (by reference) even though\n other datatypes are passed by value.  This routine converts the datatype to the appropriate pointer\n in situations where we need to get at the exact type being passed by \"value\"\n@param dt\n@return ","static":true,"name":"settleCDataType","comment":"The C language assumes array datatypes are passed simply as pointers (by reference) even though\n other datatypes are passed by value.  This routine converts the datatype to the appropriate pointer\n in situations where we need to get at the exact type being passed by \"value\"","params":[{"type_long":"ghidra.program.model.data.DataType","name":"dt","comment":"","type_short":"DataType"},{"type_long":"ghidra.program.model.data.DataTypeManager","name":"dtm","comment":"","type_short":"DataTypeManager"}],"throws":[],"return":{"type_long":"ghidra.program.model.data.DataType","comment":"","type_short":"DataType"}}],"name":"ApplyFunctionSignatureCmd","comment":"Command to create apply a function signature at an address.","fields":[]}
