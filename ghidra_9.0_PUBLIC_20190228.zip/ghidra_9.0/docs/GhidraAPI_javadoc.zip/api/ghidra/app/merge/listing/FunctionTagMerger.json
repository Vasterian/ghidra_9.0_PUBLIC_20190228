{"implements":["ghidra.app.merge.MergeResolver","ghidra.app.merge.listing.ListingMergeConstants"],"javadoc":"Class for merging function tag changes. Most tag differences can be easily auto-merged, \n which is to say the result will be the set of all of tags from both program 1 and \n program 2. Conflicts arise when both parties have edited\/deleted the same tag.\n \n The specific cases handled by the class are described below, where:\n \n  - X and Y are tags\n  - X(A) means to take A's version of tag X\n  - ** indicates a conflict\n  - NP means the situation is not possible\n  \n \t\tUser A\t|\tAdd X\tAdd Y\tDelete X\tDelete Y\tEdit X\t\tEdit Y\n \t\t\t\t|\n User B\t\t|\n ---------------------------------------------------------------------------\n Add X\t\t|\tX\t\tX,Y\t\t\tNP\t\t\tX\t\tNP\t\t\tX,Y(A)\n \t\t\t\t|\n Add Y\t\t|\tX,Y\t\tY\t\t\tY\t\t\tNP\t\tX(A),Y\t\tNP\n \t\t\t\t|\n Delete X\t\t|\tNP\t\tY\t\t\t-\t\t\t-\t\t**\t\t\tY(A)\t\t\n \t\t\t\t|\n Delete Y\t\t|\tX\t\tNP\t\t\t-\t\t\t-\t\tX(A)\t\t**\n \t\t\t\t|\n Edit X\t\t|\tNP\t\tX(B),Y\t\t**\t\t\tX(B)\t**\t\t\tX(B),Y(A)\t\n \t\t\t\t|\n Edit Y\t\t|\tX,Y(B)\tNP\t\t\tY(B)\t\t**\t\tX(A),Y(B)\t**","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"Constructor.\n@param mergeManager the merge manager\n@param resultPgm the program storing the result of the merge\n@param originalPgm the state of the program before any changes\n@param latestPgm the checked in program version\n@param myPgm the checked out program version\n@param latestChanges tag changes in Latest\n@param myChanges tag changes in My","static":false,"name":"<init>","comment":"Constructor.","params":[{"type_long":"ghidra.app.merge.ProgramMultiUserMergeManager","name":"mergeManager","comment":"the merge manager","type_short":"ProgramMultiUserMergeManager"},{"type_long":"ghidra.program.model.listing.Program","name":"resultPgm","comment":"the program storing the result of the merge","type_short":"Program"},{"type_long":"ghidra.program.model.listing.Program","name":"originalPgm","comment":"the state of the program before any changes","type_short":"Program"},{"type_long":"ghidra.program.model.listing.Program","name":"latestPgm","comment":"the checked in program version","type_short":"Program"},{"type_long":"ghidra.program.model.listing.Program","name":"myPgm","comment":"the checked out program version","type_short":"Program"},{"type_long":"ghidra.program.model.listing.ProgramChangeSet","name":"latestChanges","comment":"tag changes in Latest","type_short":"ProgramChangeSet"},{"type_long":"ghidra.program.model.listing.ProgramChangeSet","name":"myChanges","comment":"tag changes in My","type_short":"ProgramChangeSet"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"PUBLIC METHODS","static":false,"name":"getName","comment":"PUBLIC METHODS","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"","static":false,"name":"getDescription","comment":"","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"","static":false,"name":"apply","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"cancel","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"merge","comment":"","params":[{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[{"type_long":"java.lang.Exception","comment":"","type_short":"Exception"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"getPhases","comment":"","params":[],"throws":[],"return":{"type_long":"java.lang.String[][]","comment":"","type_short":"java.lang.String[][]"}},{"javadoc":"For JUnit testing only, set the option for resolving a conflict.\n@param option","static":false,"name":"setConflictResolution","comment":"For JUnit testing only, set the option for resolving a conflict.","params":[{"type_long":"int","name":"option","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}}],"name":"FunctionTagMerger","comment":"Class for merging function tag changes. Most tag differences can be easily auto-merged, \n which is to say the result will be the set of all of tags from both program 1 and \n program 2. Conflicts arise when both parties have edited\/deleted the same tag.\n \n The specific cases handled by the class are described below, where:\n \n  - X and Y are tags\n  - X(A) means to take A's version of tag X\n  - ** indicates a conflict\n  - NP means the situation is not possible\n  \n \t\tUser A\t|\tAdd X\tAdd Y\tDelete X\tDelete Y\tEdit X\t\tEdit Y\n \t\t\t\t|\n User B\t\t|\n ---------------------------------------------------------------------------\n Add X\t\t|\tX\t\tX,Y\t\t\tNP\t\t\tX\t\tNP\t\t\tX,Y(A)\n \t\t\t\t|\n Add Y\t\t|\tX,Y\t\tY\t\t\tY\t\t\tNP\t\tX(A),Y\t\tNP\n \t\t\t\t|\n Delete X\t\t|\tNP\t\tY\t\t\t-\t\t\t-\t\t**\t\t\tY(A)\t\t\n \t\t\t\t|\n Delete Y\t\t|\tX\t\tNP\t\t\t-\t\t\t-\t\tX(A)\t\t**\n \t\t\t\t|\n Edit X\t\t|\tNP\t\tX(B),Y\t\t**\t\t\tX(B)\t**\t\t\tX(B),Y(A)\t\n \t\t\t\t|\n Edit Y\t\t|\tX,Y(B)\tNP\t\t\tY(B)\t\t**\t\tX(A),Y(B)\t**","fields":[]}
