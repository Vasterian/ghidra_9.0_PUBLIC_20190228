{"implements":[],"javadoc":"Handles merging of function tags when they are added\/removed from \n functions. \n \n Most merging can be done automatically; the exception being when a\n tag has been added to a function by one user, but deleted from the\n program by another.\n \n Note that there are other tag related conflict cases, but they are \n handled by the {@link FunctionTagMerger}, which handles all aspects of\n creation\/deletion\/editing of tags independent of functions. \n \n THIS CLASS ONLY DEALS WITH FUNCTION-RELATED ADDS\/REMOVES.\n \n The specific cases handled by the class are described below:\n \n  - X and Y are tags\n  - ** indicates a conflict\n  \n \t\tUser A\t|\tAdd X\tAdd Y\tDelete X\tDelete Y\t\n \t\t\t\t|\n User B\t\t|\n -------------------------------------------------------\n Add X\t\t|\tX\t\tX,Y\t\t\t**\t\t\tX\t\t\n \t\t\t\t|\n Add Y\t\t|\tX,Y\t\tY\t\t\tY\t\t\t**\t\t\n \t\t\t\t|\n Delete X\t\t|\t**\t\tY\t\t\t-\t\t\t-\t\t\t\t\n \t\t\t\t|\n Delete Y\t\t|\tX\t\t**\t\t\t-\t\t\t-","static":false,"extends":"ghidra.app.merge.listing.AbstractListingMerger","methods":[{"javadoc":"Constructor.\n@param listingMergeMgr the listing merge manager that owns this merger.","static":false,"name":"<init>","comment":"Constructor.","params":[{"type_long":"ghidra.app.merge.listing.ListingMergeManager","name":"listingMergeMgr","comment":"the listing merge manager that owns this merger.","type_short":"ListingMergeManager"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"PUBLIC METHODS","static":false,"name":"init","comment":"PUBLIC METHODS","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"getConflictType","comment":"","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"","static":false,"name":"getConflictCount","comment":"","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"","type_short":"Address"}],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"","static":false,"name":"apply","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Stores the users' selection for how to handle a conflict.\n@param option user option, from {@link ListingMergeConstants}","static":false,"name":"setConflictResolution","comment":"Stores the users' selection for how to handle a conflict.","params":[{"type_long":"int","name":"option","comment":"user option, from ListingMergeConstants","type_short":"int"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"autoMerge","comment":"","params":[{"type_long":"int","name":"progressMin","comment":"","type_short":"int"},{"type_long":"int","name":"progressMax","comment":"","type_short":"int"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.program.util.ProgramConflictException","comment":"","type_short":"ProgramConflictException"},{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"","type_short":"MemoryAccessException"},{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"getConflicts","comment":"","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.address.AddressSetView","comment":"","type_short":"AddressSetView"}},{"javadoc":"","static":false,"name":"hasConflict","comment":"","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"","type_short":"Address"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":false,"name":"mergeConflicts","comment":"","params":[{"type_long":"ghidra.app.merge.tool.ListingMergePanel","name":"listingPanel","comment":"","type_short":"ListingMergePanel"},{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"","type_short":"Address"},{"type_long":"int","name":"chosenConflictOption","comment":"","type_short":"int"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"},{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"","type_short":"MemoryAccessException"}],"return":{"type_long":"void","comment":"","type_short":"void"}}],"name":"FunctionTagListingMerger","comment":"Handles merging of function tags when they are added\/removed from \n functions. \n \n Most merging can be done automatically; the exception being when a\n tag has been added to a function by one user, but deleted from the\n program by another.\n \n Note that there are other tag related conflict cases, but they are \n handled by the FunctionTagMerger, which handles all aspects of\n creation\/deletion\/editing of tags independent of functions. \n \n THIS CLASS ONLY DEALS WITH FUNCTION-RELATED ADDS\/REMOVES.\n \n The specific cases handled by the class are described below:\n \n  - X and Y are tags\n  - ** indicates a conflict\n  \n \t\tUser A\t|\tAdd X\tAdd Y\tDelete X\tDelete Y\t\n \t\t\t\t|\n User B\t\t|\n -------------------------------------------------------\n Add X\t\t|\tX\t\tX,Y\t\t\t**\t\t\tX\t\t\n \t\t\t\t|\n Add Y\t\t|\tX,Y\t\tY\t\t\tY\t\t\t**\t\t\n \t\t\t\t|\n Delete X\t\t|\t**\t\tY\t\t\t-\t\t\t-\t\t\t\t\n \t\t\t\t|\n Delete Y\t\t|\tX\t\t**\t\t\t-\t\t\t-","fields":[]}
