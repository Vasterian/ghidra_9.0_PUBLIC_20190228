{"implements":[],"javadoc":"A class to encapsulate LALR(1) parsing for a given grammar\n \n This class constructs the Action\/Goto table (and all the other trappings) of a LALR(1) parser\n and provides a {@link #parse(String)} method to parse actual sentences.\n \n This implementation is somewhat unconventional in that it permits ambiguous grammars. Instead of\n complaining, it produces the set of all possible parse trees. Of course, this comes at the cost\n of some efficiency.\n \n See Alfred V. Aho, Monica S. Lam, Ravi Sethi, Jeffrey D. Ullman, <i>Compilers: Principles,\n Techniques, &amp; Tools<\/i>. Bostom, MA: Pearson, 2007.\n \n See Jackson, Stephen. <a href=\"http:\/\/web.cs.dal.ca\/~sjackson\/lalr1.html\">LALR(1) Parsing<\/a>.\n Halifax, Nova Scotia, Canada: Dalhousie University.\n &lt;http:\/\/web.cs.dal.ca\/~sjackson\/lalr1.html&gt;","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"Construct a LALR(1) parser from the given grammar\n@param grammar the grammar","static":false,"name":"<init>","comment":"Construct a LALR(1) parser from the given grammar","params":[{"type_long":"ghidra.app.plugin.assembler.sleigh.grammars.AssemblyGrammar","name":"grammar","comment":"the grammar","type_short":"AssemblyGrammar"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Parse the given sentence\n@param input the sentence to parse\n@return all possible parse trees (and possible errors)","static":false,"name":"parse","comment":"Parse the given sentence","params":[{"type_long":"java.lang.String","name":"input","comment":"the sentence to parse","type_short":"String"}],"throws":[],"return":{"type_long":"java.lang.Iterable<ghidra.app.plugin.assembler.sleigh.parse.AssemblyParseResult>","comment":"all possible parse trees (and possible errors)","type_short":"Iterable"}},{"javadoc":"Parse the given sentence with the given defined labels\n@param input the sentence to parser\n@param labels a map of label to number substitutions\n@return all possible parse results (trees and errors)\n \n The tokenizer for numeric terminals also accepts any key in {@code labels.} In such cases,\n the resulting token is assigned the value of the label.","static":false,"name":"parse","comment":"Parse the given sentence with the given defined labels","params":[{"type_long":"java.lang.String","name":"input","comment":"the sentence to parser","type_short":"String"},{"type_long":"java.util.Map<java.lang.String,java.lang.Long>","name":"labels","comment":"a map of label to number substitutions","type_short":"Map"}],"throws":[],"return":{"type_long":"java.util.Collection<ghidra.app.plugin.assembler.sleigh.parse.AssemblyParseResult>","comment":"all possible parse results (trees and errors)\n \n The tokenizer for numeric terminals also accepts any key in  In such cases,\n the resulting token is assigned the value of the label.","type_short":"Collection"}},{"javadoc":"For debugging","static":false,"name":"printGrammar","comment":"For debugging","params":[{"type_long":"java.io.PrintStream","name":"out","comment":"","type_short":"PrintStream"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"For debugging","static":false,"name":"printLR0States","comment":"For debugging","params":[{"type_long":"java.io.PrintStream","name":"out","comment":"","type_short":"PrintStream"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"For debugging","static":false,"name":"printLR0TransitionTable","comment":"For debugging","params":[{"type_long":"java.io.PrintStream","name":"out","comment":"","type_short":"PrintStream"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"For debugging","static":false,"name":"printExtendedGrammar","comment":"For debugging","params":[{"type_long":"java.io.PrintStream","name":"out","comment":"","type_short":"PrintStream"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"For debugging","static":false,"name":"printGeneralFF","comment":"For debugging","params":[{"type_long":"java.io.PrintStream","name":"out","comment":"","type_short":"PrintStream"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"For debugging","static":false,"name":"printExtendedFF","comment":"For debugging","params":[{"type_long":"java.io.PrintStream","name":"out","comment":"","type_short":"PrintStream"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"For debugging","static":false,"name":"printMergers","comment":"For debugging","params":[{"type_long":"java.io.PrintStream","name":"out","comment":"","type_short":"PrintStream"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"For debugging","static":false,"name":"printParseTable","comment":"For debugging","params":[{"type_long":"java.io.PrintStream","name":"out","comment":"","type_short":"PrintStream"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"For debugging","static":false,"name":"printStuff","comment":"For debugging","params":[{"type_long":"java.io.PrintStream","name":"out","comment":"","type_short":"PrintStream"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Get the grammar used to construct this parser\n@return the grammar","static":false,"name":"getGrammar","comment":"Get the grammar used to construct this parser","params":[],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.grammars.AssemblyGrammar","comment":"the grammar","type_short":"AssemblyGrammar"}}],"name":"AssemblyParser","comment":"A class to encapsulate LALR(1) parsing for a given grammar\n \n This class constructs the Action\/Goto table (and all the other trappings) of a LALR(1) parser\n and provides a #parse(String) method to parse actual sentences.\n \n This implementation is somewhat unconventional in that it permits ambiguous grammars. Instead of\n complaining, it produces the set of all possible parse trees. Of course, this comes at the cost\n of some efficiency.\n \n See Alfred V. Aho, Monica S. Lam, Ravi Sethi, Jeffrey D. Ullman, Compilers: Principles,\n Techniques,  Tools. Bostom, MA: Pearson, 2007.\n \n See Jackson, Stephen. LALR(1) Parsing.\n Halifax, Nova Scotia, Canada: Dalhousie University.\n http:\/\/web.cs.dal.ca\/~sjackson\/lalr1.html","fields":[{"type_long":"java.util.Map<java.lang.String,java.lang.Long>","javadoc":"A convenience to specify no labels in {@link #parse(String, Map)}","static":true,"name":"EMPTY_LABELS","comment":"A convenience to specify no labels in #parse(String, Map)","type_short":"Map","constant_value":null}]}
