{"implements":[],"javadoc":"<code>SleighDebugLogger<\/code> provides the ability to obtain detailed instruction\n parse details.","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"Performs a parse debug at the specified memory location within program.\n@param buf\n@param programContext\n@param verbose if true extended debug information may be provided\n@throws IllegalArgumentException if program language provider is not Sleigh","static":false,"name":"<init>","comment":"Performs a parse debug at the specified memory location within program.","params":[{"type_long":"ghidra.program.model.mem.MemBuffer","name":"buf","comment":"","type_short":"MemBuffer"},{"type_long":"ghidra.program.model.lang.ProcessorContextView","name":"context","comment":"","type_short":"ProcessorContextView"},{"type_long":"ghidra.program.model.lang.Language","name":"language","comment":"","type_short":"Language"},{"type_long":"ghidra.app.plugin.processors.sleigh.SleighDebugLogger.SleighDebugMode","name":"mode","comment":"","type_short":"SleighDebugMode"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Performs a parse debug at the specified memory location within program.\n@param program\n@param start\n@param verbose if true extended debug information may be provided\n@throws IllegalArgumentException if program language provider is not Sleigh","static":false,"name":"<init>","comment":"Performs a parse debug at the specified memory location within program.","params":[{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"","type_short":"Program"},{"type_long":"ghidra.program.model.address.Address","name":"start","comment":"","type_short":"Address"},{"type_long":"ghidra.app.plugin.processors.sleigh.SleighDebugLogger.SleighDebugMode","name":"mode","comment":"","type_short":"SleighDebugMode"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"@return true if constructed for verbose logging","static":false,"name":"isVerboseEnabled","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if constructed for verbose logging","type_short":"boolean"}},{"javadoc":"@return true if a parse error was detected, otherwise false is returned.\n The methods getMaskedInstructionBytes() and getInstructionBitMask() should\n only be invoked if this method returns false.","static":false,"name":"parseFailed","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if a parse error was detected, otherwise false is returned.\n The methods getMaskedInstructionBytes() and getInstructionBitMask() should\n only be invoked if this method returns false.","type_short":"boolean"}},{"javadoc":"Get list of constructor names with line numbers.\n Any debug mode may be used.\n@return list","static":false,"name":"getConstructorLineNumbers","comment":"Get list of constructor names with line numbers.\n Any debug mode may be used.","params":[],"throws":[],"return":{"type_long":"java.util.List<java.lang.String>","comment":"list","type_short":"List"}},{"javadoc":"Append a binary formatted integer value with the specified range of bits\n bracketed to the log.  A -1 value for both startbit and bitcount disable the\n bit range bracketing. \n NOTE: Method has no affect unless constructed with VERBOSE logging mode.\n@param value integer value\n@param startbit identifies the first most-significant bit within the\n bracketed range (left-most value bit is bit-0, right-most value bit is bit-31)\n@param bitcount number of bits included within range","static":false,"name":"append","comment":"Append a binary formatted integer value with the specified range of bits\n bracketed to the log.  A -1 value for both startbit and bitcount disable the\n bit range bracketing. \n NOTE: Method has no affect unless constructed with VERBOSE logging mode.","params":[{"type_long":"int","name":"value","comment":"integer value","type_short":"int"},{"type_long":"int","name":"startbit","comment":"identifies the first most-significant bit within the\n bracketed range (left-most value bit is bit-0, right-most value bit is bit-31)","type_short":"int"},{"type_long":"int","name":"bitcount","comment":"number of bits included within range","type_short":"int"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Append a binary formatted integer array with the specified range of bits\n bracketed to the log.  A -1 value for both startbit and bitcount disable the\n bit range bracketing.\n NOTE: Method has no affect unless constructed with VERBOSE logging mode.\n@param value integer array\n@param startbit identifies the first most-significant bit within the\n bracketed range (left-most value[0] bit is bit-0, right-most value[n] bit is bit-<32(n+1)-1> ).\n@param bitcount number of bits included within range","static":false,"name":"append","comment":"Append a binary formatted integer array with the specified range of bits\n bracketed to the log.  A -1 value for both startbit and bitcount disable the\n bit range bracketing.\n NOTE: Method has no affect unless constructed with VERBOSE logging mode.","params":[{"type_long":"int[]","name":"value","comment":"integer array","type_short":"int[]"},{"type_long":"int","name":"startbit","comment":"identifies the first most-significant bit within the\n bracketed range (left-most value[0] bit is bit-0, right-most value[n] bit is bit-32(n+1)-1 ).","type_short":"int"},{"type_long":"int","name":"bitcount","comment":"number of bits included within range","type_short":"int"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Append a binary formatted byte array with the specified range of bits\n bracketed to the log.  A -1 value for both startbit and bitcount disable the\n bit range bracketing.\n NOTE: Method has no affect unless constructed with VERBOSE logging mode.\n@param value byte array\n@param startbit identifies the first most-significant bit within the\n bracketed range (left-most value[0] bit is bit-0, right-most value[n] bit is bit-<8(n+1)-1> ).\n@param bitcount number of bits included within range","static":false,"name":"append","comment":"Append a binary formatted byte array with the specified range of bits\n bracketed to the log.  A -1 value for both startbit and bitcount disable the\n bit range bracketing.\n NOTE: Method has no affect unless constructed with VERBOSE logging mode.","params":[{"type_long":"byte[]","name":"value","comment":"byte array","type_short":"byte[]"},{"type_long":"int","name":"startbit","comment":"identifies the first most-significant bit within the\n bracketed range (left-most value[0] bit is bit-0, right-most value[n] bit is bit-8(n+1)-1 ).","type_short":"int"},{"type_long":"int","name":"bitcount","comment":"number of bits included within range","type_short":"int"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Append message string to log buffer.\n NOTE: Method has no affect unless constructed with VERBOSE logging mode.\n@param str message string","static":false,"name":"append","comment":"Append message string to log buffer.\n NOTE: Method has no affect unless constructed with VERBOSE logging mode.","params":[{"type_long":"java.lang.String","name":"str","comment":"message string","type_short":"String"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Shift log indent right","static":false,"name":"indent","comment":"Shift log indent right","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"indent","comment":"","params":[{"type_long":"int","name":"levels","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Shift log indent left","static":false,"name":"dropIndent","comment":"Shift log indent left","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"dropIndent","comment":"","params":[{"type_long":"int","name":"levels","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Return log text","static":false,"name":"toString","comment":"Return log text","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"Dump context pattern details.\n NOTE: Method has no affect unless constructed with VERBOSE logging mode.\n@param maskvec\n@param valvec\n@param byteOffset\n@param pos","static":false,"name":"dumpContextPattern","comment":"Dump context pattern details.\n NOTE: Method has no affect unless constructed with VERBOSE logging mode.","params":[{"type_long":"int[]","name":"maskvec","comment":"","type_short":"int[]"},{"type_long":"int[]","name":"valvec","comment":"","type_short":"int[]"},{"type_long":"int","name":"byteOffset","comment":"","type_short":"int"},{"type_long":"ghidra.app.plugin.processors.sleigh.SleighParserContext","name":"pos","comment":"","type_short":"SleighParserContext"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Dump transient context setting details.\n NOTE: Method has no affect unless constructed with VERBOSE logging mode.\n@param pos instruction context\n@param num 4-byte offset within base context register for mask and value\n@param value 4-byte context value\n@param mask 4-byte context mask","static":false,"name":"dumpContextSet","comment":"Dump transient context setting details.\n NOTE: Method has no affect unless constructed with VERBOSE logging mode.","params":[{"type_long":"ghidra.app.plugin.processors.sleigh.SleighParserContext","name":"pos","comment":"instruction context","type_short":"SleighParserContext"},{"type_long":"int","name":"num","comment":"4-byte offset within base context register for mask and value","type_short":"int"},{"type_long":"int","name":"value","comment":"4-byte context value","type_short":"int"},{"type_long":"int","name":"mask","comment":"4-byte context mask","type_short":"int"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Dump globalset details.  The target address is currently not included in the log.\n NOTE: Method has no affect unless constructed with VERBOSE logging mode.\n@param pos\n@param state\n@param sym\n@param num\n@param mask\n@param value\n@throws MemoryAccessException","static":false,"name":"dumpGlobalSet","comment":"Dump globalset details.  The target address is currently not included in the log.\n NOTE: Method has no affect unless constructed with VERBOSE logging mode.","params":[{"type_long":"ghidra.app.plugin.processors.sleigh.SleighParserContext","name":"pos","comment":"","type_short":"SleighParserContext"},{"type_long":"ghidra.app.plugin.processors.sleigh.ConstructState","name":"state","comment":"","type_short":"ConstructState"},{"type_long":"ghidra.app.plugin.processors.sleigh.symbol.TripleSymbol","name":"sym","comment":"","type_short":"TripleSymbol"},{"type_long":"int","name":"num","comment":"","type_short":"int"},{"type_long":"int","name":"mask","comment":"","type_short":"int"},{"type_long":"int","name":"value","comment":"","type_short":"int"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"","type_short":"MemoryAccessException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Start new pattern group for a specific sub-table.  \n A null can correspond to a top-level constructor or \n low level complex pattern (AND, OR).  All committed unnamed groups \n with the same parent group will be combined.\n@param name group name or null for unnamed group","static":false,"name":"startPatternGroup","comment":"Start new pattern group for a specific sub-table.  \n A null can correspond to a top-level constructor or \n low level complex pattern (AND, OR).  All committed unnamed groups \n with the same parent group will be combined.","params":[{"type_long":"java.lang.String","name":"name","comment":"group name or null for unnamed group","type_short":"String"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Terminate the current pattern group\n@param commit if false group will be discarded, if true group will be retained","static":false,"name":"endPatternGroup","comment":"Terminate the current pattern group","params":[{"type_long":"boolean","name":"commit","comment":"if false group will be discarded, if true group will be retained","type_short":"boolean"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Add instruction bit pattern to the current pattern group.\n@param offset base offset at which the specified maskvalue\n can be applied.\n@param maskvalue pattern mask\/value","static":false,"name":"addInstructionPattern","comment":"Add instruction bit pattern to the current pattern group.","params":[{"type_long":"int","name":"offset","comment":"base offset at which the specified maskvalue\n can be applied.","type_short":"int"},{"type_long":"ghidra.app.plugin.processors.sleigh.pattern.PatternBlock","name":"maskvalue","comment":"pattern mask\/value","type_short":"PatternBlock"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Add instruction context pattern to the current pattern group.\n@param maskvalue pattern mask\/value","static":false,"name":"addContextPattern","comment":"Add instruction context pattern to the current pattern group.","params":[{"type_long":"ghidra.app.plugin.processors.sleigh.pattern.PatternBlock","name":"maskvalue","comment":"pattern mask\/value","type_short":"PatternBlock"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns the instruction bit mask which identifies those bits used to uniquely identify\n the instruction (includes addressing modes, generally excludes register selector bits\n associated with attaches or immediate values used in for semantic values only).\n@throws IllegalStateException if prototype parse failed\n@see SleighDebugLogger#getMaskedInstructionBytes()","static":false,"name":"getInstructionMask","comment":"Returns the instruction bit mask which identifies those bits used to uniquely identify\n the instruction (includes addressing modes, generally excludes register selector bits\n associated with attaches or immediate values used in for semantic values only).","params":[],"throws":[],"return":{"type_long":"byte[]","comment":"","type_short":"byte[]"}},{"javadoc":"Return general\/operand bit mask formatted as a String\n@param opIndex operand index or -1 for mnemonic mask\n@return bit mask string","static":false,"name":"getFormattedInstructionMask","comment":"Return general\/operand bit mask formatted as a String","params":[{"type_long":"int","name":"opIndex","comment":"operand index or -1 for mnemonic mask","type_short":"int"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"bit mask string","type_short":"String"}},{"javadoc":"Return general\/operand bit values formatted as a String\n@param opIndex operand index or -1 for mnemonic bit values\n@return bit value string","static":false,"name":"getFormattedMaskedValue","comment":"Return general\/operand bit values formatted as a String","params":[{"type_long":"int","name":"opIndex","comment":"operand index or -1 for mnemonic bit values","type_short":"int"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"bit value string","type_short":"String"}},{"javadoc":"Convenience method for formatting bytes as a bit sequence\n@param value byte array\n@return binary formatted bytes","static":true,"name":"getFormattedBytes","comment":"Convenience method for formatting bytes as a bit sequence","params":[{"type_long":"byte[]","name":"value","comment":"byte array","type_short":"byte[]"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"binary formatted bytes","type_short":"String"}},{"javadoc":"Get the number of operands for the resulting prototype\n@return operand count\n@throws IllegalStateException if prototype parse failed","static":false,"name":"getNumOperands","comment":"Get the number of operands for the resulting prototype","params":[],"throws":[],"return":{"type_long":"int","comment":"operand count","type_short":"int"}},{"javadoc":"Apply an appropriate mask for the resulting instruction bytes\n to obtain the corresponding masked bytes.\n@param mask instruction, operand or similarly sized mask\n@return masked instruction bytes","static":false,"name":"getMaskedBytes","comment":"Apply an appropriate mask for the resulting instruction bytes\n to obtain the corresponding masked bytes.","params":[{"type_long":"byte[]","name":"mask","comment":"instruction, operand or similarly sized mask","type_short":"byte[]"}],"throws":[],"return":{"type_long":"byte[]","comment":"masked instruction bytes","type_short":"byte[]"}},{"javadoc":"Get the byte value mask corresponding to the specified operand.\n@param opIndex operand index within the instruction representation\n@return byte mask or null if operand does not have a corresponding sub-constructor or attach\n@throws IllegalStateException if prototype parse failed\n@throws IndexOutOfBoundsException if opIndex is not a valid operand index","static":false,"name":"getOperandValueMask","comment":"Get the byte value mask corresponding to the specified operand.","params":[{"type_long":"int","name":"opIndex","comment":"operand index within the instruction representation","type_short":"int"}],"throws":[],"return":{"type_long":"byte[]","comment":"byte mask or null if operand does not have a corresponding sub-constructor or attach","type_short":"byte[]"}}],"name":"SleighDebugLogger","comment":"SleighDebugLogger provides the ability to obtain detailed instruction\n parse details.","fields":[]}
