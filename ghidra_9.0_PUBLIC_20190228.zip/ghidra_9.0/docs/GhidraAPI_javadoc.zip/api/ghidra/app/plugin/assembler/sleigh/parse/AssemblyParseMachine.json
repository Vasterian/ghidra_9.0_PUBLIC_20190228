{"implements":["java.lang.Comparable"],"javadoc":"A class that implements the LALR(1) parsing algorithm\n \n Instances of this class store a parse state. In order to work correctly, the class must be\n given a properly-constructed Action\/Goto table.\n \n This implementation is somewhat unconventional. First, instead of strictly tokenizing and then\n parsing, each terminal is given the opportunity to match a token in the input. If none match, it\n results in a syntax error (equivalent to the token type having an empty cell in the classical\n algorithm). If more than one match, the parser branches. Also, because a single cell may also\n contain multiple actions, the parser could branch again. Thus, if a sentence is ambiguous, this\n algorithm will identify all possible parse trees, including ones where the input is tokenized\n differently than in other trees.","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"Construct a new parse state\n@param parser the parser driving this machine\n@param input the full input line\n@param pos the position in the line identifying the next characters to parse\n@param labels a map of valid tokens to number for numeric terminals","static":false,"name":"<init>","comment":"Construct a new parse state","params":[{"type_long":"ghidra.app.plugin.assembler.sleigh.parse.AssemblyParser","name":"parser","comment":"the parser driving this machine","type_short":"AssemblyParser"},{"type_long":"java.lang.String","name":"input","comment":"the full input line","type_short":"String"},{"type_long":"int","name":"pos","comment":"the position in the line identifying the next characters to parse","type_short":"int"},{"type_long":"ghidra.app.plugin.assembler.sleigh.tree.AssemblyParseToken","name":"lastTok","comment":"","type_short":"AssemblyParseToken"},{"type_long":"java.util.Map<java.lang.String,java.lang.Long>","name":"labels","comment":"a map of valid tokens to number for numeric terminals","type_short":"Map"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"hashCode","comment":"","params":[],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"","static":false,"name":"equals","comment":"","params":[{"type_long":"java.lang.Object","name":"that","comment":"","type_short":"Object"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":false,"name":"compareTo","comment":"","params":[{"type_long":"ghidra.app.plugin.assembler.sleigh.parse.AssemblyParseMachine","name":"that","comment":"","type_short":"AssemblyParseMachine"}],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"Duplicate this machine state\n \n This is used extensively when branching\n@return the duplicate","static":false,"name":"copy","comment":"Duplicate this machine state\n \n This is used extensively when branching","params":[],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.parse.AssemblyParseMachine","comment":"the duplicate","type_short":"AssemblyParseMachine"}},{"javadoc":"","static":false,"name":"toString","comment":"","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"Parse (or continue parsing) all possible trees from this machine state\n@return the set of all possible trees and errors","static":false,"name":"exhaust","comment":"Parse (or continue parsing) all possible trees from this machine state","params":[],"throws":[],"return":{"type_long":"java.util.Set<ghidra.app.plugin.assembler.sleigh.parse.AssemblyParseMachine>","comment":"the set of all possible trees and errors","type_short":"Set"}},{"javadoc":"If in the accepted state, get the resulting parse tree for this machine\n@return the parse tree","static":false,"name":"getTree","comment":"If in the accepted state, get the resulting parse tree for this machine","params":[],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.tree.AssemblyParseBranch","comment":"the parse tree","type_short":"AssemblyParseBranch"}}],"name":"AssemblyParseMachine","comment":"A class that implements the LALR(1) parsing algorithm\n \n Instances of this class store a parse state. In order to work correctly, the class must be\n given a properly-constructed Action\/Goto table.\n \n This implementation is somewhat unconventional. First, instead of strictly tokenizing and then\n parsing, each terminal is given the opportunity to match a token in the input. If none match, it\n results in a syntax error (equivalent to the token type having an empty cell in the classical\n algorithm). If more than one match, the parser branches. Also, because a single cell may also\n contain multiple actions, the parser could branch again. Thus, if a sentence is ambiguous, this\n algorithm will identify all possible parse trees, including ones where the input is tokenized\n differently than in other trees.","fields":[]}
