{"implements":["ghidra.app.plugin.assembler.AssemblerBuilder"],"javadoc":"An {@link AssemblerBuilder} capable of supporting almost any {@link SleighLanguage}\n \n To build an assembler, please use a static method of the {@link Assemblers} class.\n \n SLEIGH-based assembly is a bit of an experimental feature at this time. Nevertheless, it seems to\n have come along quite nicely. It's not quite as fast as disassembly, since after all, that's what\n SLEIGH was designed to do.\n \n Overall, the method is fairly simple, though its implementation is a bit more complex. First, we\n gather every pair of pattern and constructor by traversing the decision tree used by disassembly.\n We then use the \"print pieces\" to construct a context-free grammar. Each production is associated\n with the one-or-more constructors with the same sequence of print pieces. We then build a LALR(1)\n parser for the generated grammar. This now constitutes a generic parser for the given language.\n Note that this step takes some time, and may be better suited as a build-time step. Because\n SLEIGH specifications are not generally concerned with eliminating ambiguity of printed\n instructions (rather, it only does so for instruction bytes), we must consider that the grammar\n could be ambiguous. To handle this, the action\/goto table is permitted multiple entries per cell,\n and we allow backtracking. There are also cases where tokens are not actually separated by\n spaces. For example, in the {@code ia.sinc} file, there is JMP ... and J^cc, meaning, the lexer\n must consider J as a token as well as JMP, introducing another source of possible backtracking.\n Despite that, parsing is completed fairly quickly.\n \n To assemble, we first parse the textual instruction, yielding zero or more parse trees. No parse\n trees implies an error. For each parse tree, we attempt to resolve the instruction bytes,\n starting at the leaves and working upwards while tracking and solving context changes. The\n context changes must be considered in reverse. We <em>read<\/em> the context register of the\n children (a disassembler would write). We then assume there is at most one variable in the\n expression, solve for it, and <em>write<\/em> the solution to the appropriate field (a\n disassembler would read). If no solution exists, a semantic error is logged. Since it's possible\n a production in the parse tree is associated with multiple constructors, different combinations\n of constructors are explored as we move upward in the tree. If all possible combinations yield\n semantic errors, then the overall result is an error.\n \n Some productions are \"purely recursive,\" e.g., {@code :^instruction} lines in the SLEIGH. These\n are ignored during parser construction. Let such a production be given as I => I. When resolving\n the parse tree to bytes, and we encounter a production with I on the left hand side, we then\n consider the possible application of the production I => I and its consequential constructors.\n Ideally, we could repeat this indefinitely, stopping when all further applications result in\n semantic errors; however, there is no guarantee in the SLEIGH specification that such an\n algorithm will actually halt, so a maximum number (default of 1) of applications are attempted.\n \n After all the context changes and operands are resolved, we apply the constructor patterns and\n proceed up the tree. Thus, each branch yields zero or more \"resolved constructors,\" which each\n specify two masked blocks of data: one for the instruction, and one for the context. These are\n passed up to the parent production, which, having obtained results from all its children,\n attempts to apply the corresponding constructors.\n \n Once we've resolved the root node, any resolved constructors returned are taken as successfully\n assembled instruction bytes. If applicable, the corresponding context registers are compared to\n the context at the target address in the program and filtered for compatibility.","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"Construct an assembler builder for the given SLEIGH language\n@param lang the language","static":false,"name":"<init>","comment":"Construct an assembler builder for the given SLEIGH language","params":[{"type_long":"ghidra.app.plugin.processors.sleigh.SleighLanguage","name":"lang","comment":"the language","type_short":"SleighLanguage"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"getLanguageID","comment":"","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.lang.LanguageID","comment":"","type_short":"LanguageID"}},{"javadoc":"","static":false,"name":"getLanguage","comment":"","params":[],"throws":[],"return":{"type_long":"ghidra.app.plugin.processors.sleigh.SleighLanguage","comment":"","type_short":"SleighLanguage"}},{"javadoc":"","static":false,"name":"getAssembler","comment":"","params":[{"type_long":"ghidra.app.plugin.assembler.AssemblySelector","name":"selector","comment":"","type_short":"AssemblySelector"}],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.SleighAssembler","comment":"","type_short":"SleighAssembler"}},{"javadoc":"","static":false,"name":"getAssembler","comment":"","params":[{"type_long":"ghidra.app.plugin.assembler.AssemblySelector","name":"selector","comment":"","type_short":"AssemblySelector"},{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"","type_short":"Program"}],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.SleighAssembler","comment":"","type_short":"SleighAssembler"}}],"name":"SleighAssemblerBuilder","comment":"An AssemblerBuilder capable of supporting almost any SleighLanguage\n \n To build an assembler, please use a static method of the Assemblers class.\n \n SLEIGH-based assembly is a bit of an experimental feature at this time. Nevertheless, it seems to\n have come along quite nicely. It's not quite as fast as disassembly, since after all, that's what\n SLEIGH was designed to do.\n \n Overall, the method is fairly simple, though its implementation is a bit more complex. First, we\n gather every pair of pattern and constructor by traversing the decision tree used by disassembly.\n We then use the \"print pieces\" to construct a context-free grammar. Each production is associated\n with the one-or-more constructors with the same sequence of print pieces. We then build a LALR(1)\n parser for the generated grammar. This now constitutes a generic parser for the given language.\n Note that this step takes some time, and may be better suited as a build-time step. Because\n SLEIGH specifications are not generally concerned with eliminating ambiguity of printed\n instructions (rather, it only does so for instruction bytes), we must consider that the grammar\n could be ambiguous. To handle this, the action\/goto table is permitted multiple entries per cell,\n and we allow backtracking. There are also cases where tokens are not actually separated by\n spaces. For example, in the  file, there is JMP ... and J^cc, meaning, the lexer\n must consider J as a token as well as JMP, introducing another source of possible backtracking.\n Despite that, parsing is completed fairly quickly.\n \n To assemble, we first parse the textual instruction, yielding zero or more parse trees. No parse\n trees implies an error. For each parse tree, we attempt to resolve the instruction bytes,\n starting at the leaves and working upwards while tracking and solving context changes. The\n context changes must be considered in reverse. We read the context register of the\n children (a disassembler would write). We then assume there is at most one variable in the\n expression, solve for it, and write the solution to the appropriate field (a\n disassembler would read). If no solution exists, a semantic error is logged. Since it's possible\n a production in the parse tree is associated with multiple constructors, different combinations\n of constructors are explored as we move upward in the tree. If all possible combinations yield\n semantic errors, then the overall result is an error.\n \n Some productions are \"purely recursive,\" e.g.,  lines in the SLEIGH. These\n are ignored during parser construction. Let such a production be given as I = I. When resolving\n the parse tree to bytes, and we encounter a production with I on the left hand side, we then\n consider the possible application of the production I = I and its consequential constructors.\n Ideally, we could repeat this indefinitely, stopping when all further applications result in\n semantic errors; however, there is no guarantee in the SLEIGH specification that such an\n algorithm will actually halt, so a maximum number (default of 1) of applications are attempted.\n \n After all the context changes and operands are resolved, we apply the constructor patterns and\n proceed up the tree. Thus, each branch yields zero or more \"resolved constructors,\" which each\n specify two masked blocks of data: one for the instruction, and one for the context. These are\n passed up to the parent production, which, having obtained results from all its children,\n attempts to apply the corresponding constructors.\n \n Once we've resolved the root node, any resolved constructors returned are taken as successfully\n assembled instruction bytes. If applicable, the corresponding context registers are compared to\n the context at the target address in the program and filtered for compatibility.","fields":[]}
