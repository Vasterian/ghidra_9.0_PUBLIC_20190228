{"implements":["ghidra.util.classfinder.ExtensionPoint","ghidra.framework.plugintool.util.PluginEventListener","ghidra.framework.plugintool.util.ServiceListener"],"javadoc":"Plugins are a basic building block in Ghidra, used to bundle features or capabilities\n into a unit that can be enabled or disabled by the user in their Tool.\n <p>\n Plugins expose their features or capabilities to users via menu items and buttons that\n the user can click on, and via \"service\" APIs that other Plugins can programmatically subscribe\n to, and via {@link PluginEvent}s that are broadcast.\n <p>\n <h2>Well formed Plugins:<\/h2>\n <UL>\n \t<LI>Derive from <code>Plugin<\/code> (directly or indirectly).\n \t<LI>Class name ends with \"Plugin\" and does not match any other Plugin, regardless of\n \tits location in the package tree.\n \t<LI>Have a {@link PluginInfo @PluginInfo()} annotation.\n \t<LI>Have a constructor with exactly 1 parameter: PluginTool.\n \t\t<UL>\n  \t\t\t<LI><code>public MyPlugin(PluginTool tool) { ... }<\/code>\n  \t\t<\/UL>\n  \t<LI>Usually overrides <code>protected void init()<\/code>.\n <\/UL>\n <h2>Class naming<\/h2>\n All Plugin Classes <b>MUST END IN<\/b> \"Plugin\".  If not, the ClassSearcher will not find them.\n <p>\n Some special Plugins marked with the {@link ProgramaticUseOnly} interface are manually\n created and do not follow this naming requirement.\n\n <h2>Plugin Life cycle<\/h2>\n <OL>\n \t<LI>Your Plugin's constructor is called\n \t\t<OL>\n \t\t\t<LI>Plugin base class constructor is called.\n \t\t\t\t<OL>\n \t\t\t\t\t<LI>Services listed in the @PluginInfo annotation are automatically added\n \t\t\t\t\tto dependency list\n \t\t\t\t<\/OL>\n \t\t\t<LI>Your Plugin publishes any services listed in PluginInfo using\n \t\t\t{@link Plugin#registerServiceProvided(Class, Object) registerServiceProvided()}.\n \t\t\t(required)\n  \t\t\t<LI>Create Actions (optional)\n  \t\t\t<LI>Register {@link Options} with the {@link PluginTool#getOptions(String)}. (optional)<br>\n \t\t<\/OL>\n \t<LI>Other Plugins are constructed, dependencies evaluated, etc.<br>\n \tIf your dependencies are not available (ie. not installed, threw an exception during their\n\tinitialization, etc), your Plugin's {@link #dispose()} will be called and then your Plugin\n\tinstance will be discarded.<br>\n\t<LI>Your Plugin's {@link #init()} method is called (when its dependencies are met).\n \t\t<OL>\n \t\t\t<LI>Call {@link PluginTool#getService(Class)} to get service\n \t\t\timplementations. (the service class being requested should already be\n \t\t\tlisted in the @PluginInfo)\n \t\t\t<LI>Create Actions (optional)\n \t\t\t<LI>Other initialization stuff.\n \t\t<\/OL>\n\t<LI>Your Plugin's {@link #readConfigState(SaveState)} is called.\n \t<LI>...user uses Ghidra...\n \t\t<UL>\n \t\t\t<LI>Your Plugin's {@link #processEvent(PluginEvent)} is called for events.\n \t\t\t<LI>Your Plugin's Action's methods (ie.\n \t\t\t{@link DockingAction#actionPerformed(docking.ActionContext) actionPerformed}) are called.\n \t\t\t<LI>Your Plugin's published service methods are called by other Plugins.\n \t\t\t<LI>Your Plugin's listener methods are called.\n \t\t<\/UL>\n \t<LI>Plugin is unloaded due to shutdown of the Tool or being disabled by user\n \t\t<OL>\n\t\t\t<LI>Your Plugin's {@link #writeConfigState(SaveState)} is called - override this\n\t\t\tmethod to write configuration info into the Tool definition.\n \t\t\t<LI>Your Plugin's {@link #dispose()} is called - override this method to free\n \t\t\tany resources and perform any needed cleanup.\n \t\t\t<LI>Your Plugin's services and events are de-registered automatically.\n \t\t<\/OL>\n <\/OL>\n\n <h2>Plugin Service dependency<\/h2>\n All Plugins must be tagged with a {@link PluginInfo @PluginInfo(...)} annotation.\n <p>\n The annotation gives you the ability to declare a dependency on another Plugin\n via the {@link PluginInfo#servicesRequired() servicesRequired} \/\n {@link PluginInfo#servicesUsed() servicesUsed}\n <p>\n Ghidra will ensure that your Plugin will not be {@link #init() initialized} until all\n of its required services are loaded successfully and are available for use when your Plugin\n calls the {@link PluginTool#getService(Class)} method.\n <p>\n Conversely, any services your Plugin advertises in &#64;PluginInfo must be published via calls to\n {@link #registerServiceProvided(Class, Object) registerServiceProvided()} in your Plugin's constructor.\n <p>\n <b>Cyclic dependencies<\/b> are not allowed and will cause the Plugin management code to fail to load\n your Plugin. (ie. PluginA requires a service that PluginB provides, which requires a service\n that PluginA provides)\n\n <h2>Plugin Service implementation<\/h2>\n A Plugin may provide a service to other Plugins by advertising in its {@link PluginInfo}\n annotation that it {@link PluginInfo#servicesProvided() provides} an interface class.\n <p>\n Your Plugin can either directly implement the interface in your Plugin class:\n <p>\n &nbsp;&nbsp;<code>public class MyPlugin extends Plugin <b>implements MyService<\/b> {....}<\/code>\n <p>\n or it may delegate the handling of the service interface to another object during its\n constructor:\n <p>\n &nbsp;&nbsp;<code>public MyPlugin(PluginTool tool) {<\/code><br>\n &nbsp;&nbsp;&nbsp;&nbsp;<code>...<\/code><br>\n &nbsp;&nbsp;&nbsp;&nbsp;<code>MyService serviceObj = new MyService() { ... };<\/code><br>\n &nbsp;&nbsp;&nbsp;&nbsp;<code><b>registerServiceProvided(MyService.class, serviceObj);<\/b><\/code><br>\n &nbsp;&nbsp;<code>}<\/code><br>\n <p>\n When your Plugin directly implements the advertised service interface, you should <b>not<\/b>\n call {@link #registerServiceProvided(Class, Object) registerServiceProvided} for that service\n interface.\n <p>\n Service interface classes are just normal java interface declarations and have no\n preconditions or other requirements to be used as a Plugin's advertised service interface.\n <p>\n Optionally, service interface classes can be marked with meta-data via a\n {@link ServiceInfo @ServiceInfo} annotation that can have a\n {@link ServiceInfo#defaultProvider() defaultProvider} property which specifies a Plugin's\n class (or classname) that should be auto-loaded to provide an implementation of the service\n interface when that service is required by some other Plugin.  Without the defaultProvider\n information, dependent Plugins will fail to load unless the user manually loads a Plugin\n that provides the necessary interface service.\n <p>\n Multiple Plugins can implement the same service interface.  Plugins that use that\n multi-implemented service will either receive a randomly picked instance if using\n {@link PluginTool#getService(Class)} or will receive all implementations if using\n {@link PluginTool#getServices(Class)}.\n <p>\n\n <h2>Plugin Events<\/h2>\n <UL>\n \t<LI>Every type of plugin event should be represented by some class extending {@link PluginEvent}.\n  <LI>One PluginEvent subclass may be used for more than one event type as long as there's some natural grouping.\n <\/UL>\n\n <h2>Component Providers<\/h2>\n <UL>\n  <LI>A plugin may supply a ComponentProvider that provides a visual component when the plugin is added to the tool.\n  <LI>TODO - needs more\n <\/UL>\n\n <h2>Important interfaces Plugins often need to implement<\/h2>\n <UL>\n \t<LI>{@link OptionsChangeListener} - to receive notification when a configuration option\n \tis changed by the user.\n \t<LI>{@link FrontEndable} - marks this Plugin as being suitable for inclusion in the FrontEnd tool.\n \t<LI>{@link FrontEndOnly} - marks this Plugin as FrontEnd only, not usable in CodeBrowser or other tools.\n \t<LI>{@link ProgramaticUseOnly} - marks this Plugin as special and not for user configuration.\n \t<LI>TODO\n <\/UL>","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"Returns plugin name or null if pluginClass does not extend Plugin.\n <p>\n Deprecated, use {@link PluginUtils#getPluginNameFromClass(Class)}\n <p>\n@param pluginClass","static":true,"name":"getPluginName","comment":"Returns plugin name or null if pluginClass does not extend Plugin.\n \n Deprecated, use PluginUtils#getPluginNameFromClass(Class)\n ","params":[{"type_long":"java.lang.Class<?>","name":"pluginClass","comment":"","type_short":"Class"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"Returns this plugin's name.\n <p>\n@return String name, derived from simple class name.","static":false,"name":"getName","comment":"Returns this plugin's name.\n ","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"String name, derived from simple class name.","type_short":"String"}},{"javadoc":"","static":false,"name":"eventSent","comment":"","params":[{"type_long":"ghidra.framework.plugintool.PluginEvent","name":"event","comment":"","type_short":"PluginEvent"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Method called to process a plugin event.  Plugins should override this method\n if the plugin processes PluginEvents;\n@param event plugin to process","static":false,"name":"processEvent","comment":"Method called to process a plugin event.  Plugins should override this method\n if the plugin processes PluginEvents;","params":[{"type_long":"ghidra.framework.plugintool.PluginEvent","name":"event","comment":"plugin to process","type_short":"PluginEvent"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Get the {@link PluginTool} that hosts\/contains this plugin.\n@return PluginTool","static":false,"name":"getTool","comment":"Get the PluginTool that hosts\/contains this plugin.","params":[],"throws":[],"return":{"type_long":"ghidra.framework.plugintool.PluginTool","comment":"PluginTool","type_short":"PluginTool"}},{"javadoc":"Return classes of data types that this plugin can support.\n <p>\n@return classes of data types that this plugin can support","static":false,"name":"getSupportedDataTypes","comment":"Return classes of data types that this plugin can support.\n ","params":[],"throws":[],"return":{"type_long":"java.lang.Class<?>[]","comment":"classes of data types that this plugin can support","type_short":"java.lang.Class<?>[]"}},{"javadoc":"Method called if the plugin supports this domain file.\n <p>\n@param data array of {@link DomainFile}s\n@return boolean true if can accept","static":false,"name":"acceptData","comment":"Method called if the plugin supports this domain file.\n ","params":[{"type_long":"ghidra.framework.model.DomainFile[]","name":"data","comment":"array of DomainFiles","type_short":"ghidra.framework.model.DomainFile[]"}],"throws":[],"return":{"type_long":"boolean","comment":"boolean true if can accept","type_short":"boolean"}},{"javadoc":"Get the domain files that this plugin has open.\n <p>\n@return array of {@link DomainFile}s that are open by this Plugin.","static":false,"name":"getData","comment":"Get the domain files that this plugin has open.\n ","params":[],"throws":[],"return":{"type_long":"ghidra.framework.model.DomainFile[]","comment":"array of DomainFiles that are open by this Plugin.","type_short":"ghidra.framework.model.DomainFile[]"}},{"javadoc":"Tells the Plugin to read its data-independent (preferences)\n properties from the input stream.\n@param saveState object that holds primitives for state information","static":false,"name":"readConfigState","comment":"Tells the Plugin to read its data-independent (preferences)\n properties from the input stream.","params":[{"type_long":"ghidra.framework.options.SaveState","name":"saveState","comment":"object that holds primitives for state information","type_short":"SaveState"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Tells a Plugin to write any data-independent (preferences)\n properties to the output stream.\n@param saveState object that holds primitives for state information","static":false,"name":"writeConfigState","comment":"Tells a Plugin to write any data-independent (preferences)\n properties to the output stream.","params":[{"type_long":"ghidra.framework.options.SaveState","name":"saveState","comment":"object that holds primitives for state information","type_short":"SaveState"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Tells the Plugin to write any data-dependent state to the\n output stream.\n@param saveState object that holds primitives for state information","static":false,"name":"writeDataState","comment":"Tells the Plugin to write any data-dependent state to the\n output stream.","params":[{"type_long":"ghidra.framework.options.SaveState","name":"saveState","comment":"object that holds primitives for state information","type_short":"SaveState"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Tells the Plugin to read its data-dependent state from the\n given SaveState object.\n@param saveState object that holds primitives for state information","static":false,"name":"readDataState","comment":"Tells the Plugin to read its data-dependent state from the\n given SaveState object.","params":[{"type_long":"ghidra.framework.options.SaveState","name":"saveState","comment":"object that holds primitives for state information","type_short":"SaveState"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Fire the given plugin event; the tool notifies all other plugins\n who are interested in receiving the given event type.\n@param event event to fire","static":false,"name":"firePluginEvent","comment":"Fire the given plugin event; the tool notifies all other plugins\n who are interested in receiving the given event type.","params":[{"type_long":"ghidra.framework.plugintool.PluginEvent","name":"event","comment":"event to fire","type_short":"PluginEvent"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Notifies this plugin that a service has been added to\n   the plugin tool.\n Plugins should override this method if they update their state\n when a particular service is added.\n@param interfaceClass The <b>interface<\/i> of the added service\n@param service service that is being added","static":false,"name":"serviceAdded","comment":"Notifies this plugin that a service has been added to\n   the plugin tool.\n Plugins should override this method if they update their state\n when a particular service is added.","params":[{"type_long":"java.lang.Class<?>","name":"interfaceClass","comment":"The interface of the added service","type_short":"Class"},{"type_long":"java.lang.Object","name":"service","comment":"service that is being added","type_short":"Object"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Notifies this plugin that service has been removed from the\n   plugin tool.\n Plugins should override this method if they update their state\n when a particular service is removed.\n@param interfaceClass The <b>interface<\/i> of the added service\n@param service that is being removed.","static":false,"name":"serviceRemoved","comment":"Notifies this plugin that service has been removed from the\n   plugin tool.\n Plugins should override this method if they update their state\n when a particular service is removed.","params":[{"type_long":"java.lang.Class<?>","name":"interfaceClass","comment":"The interface of the added service","type_short":"Class"},{"type_long":"java.lang.Object","name":"service","comment":"that is being removed.","type_short":"Object"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Check if this plugin depends on the given plugin.\n <p>","static":false,"name":"dependsUpon","comment":"Check if this plugin depends on the given plugin.\n ","params":[{"type_long":"ghidra.framework.plugintool.Plugin","name":"plugin","comment":"","type_short":"Plugin"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":false,"name":"getMissingRequiredServices","comment":"","params":[],"throws":[],"return":{"type_long":"java.util.List<java.lang.Class<?>>","comment":"","type_short":"List"}},{"javadoc":"Checks if this plugin is missing a required service.\n@return boolean true if a required service isn't available via the PluginTool.","static":false,"name":"hasMissingRequiredService","comment":"Checks if this plugin is missing a required service.","params":[],"throws":[],"return":{"type_long":"boolean","comment":"boolean true if a required service isn't available via the PluginTool.","type_short":"boolean"}},{"javadoc":"","static":false,"name":"isDisposed","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":false,"name":"equals","comment":"","params":[{"type_long":"java.lang.Object","name":"obj","comment":"","type_short":"Object"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":false,"name":"hashCode","comment":"","params":[],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"Provides the transient state object that was returned in the corresponding getTransientState()\n call.  Plugins should override this method if they have state that needs to be saved as domain objects\n get switched between active and inactive.\n@param state the state object that was generated by this plugin's getTransientState() method.","static":false,"name":"restoreTransientState","comment":"Provides the transient state object that was returned in the corresponding getTransientState()\n call.  Plugins should override this method if they have state that needs to be saved as domain objects\n get switched between active and inactive.","params":[{"type_long":"java.lang.Object","name":"state","comment":"the state object that was generated by this plugin's getTransientState() method.","type_short":"Object"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns an object containing the plugins state.  Plugins should override this method if\n they have state that they want to maintain between domain object state transitions (i.e. when the\n user tabs to a different domain object and back) Whatever object is returned will be fed back to\n the plugin after the tool state is switch back to the domain object that was active when the this\n method was called.\n@return Object to be return in the restoreTransientState() method.","static":false,"name":"getTransientState","comment":"Returns an object containing the plugins state.  Plugins should override this method if\n they have state that they want to maintain between domain object state transitions (i.e. when the\n user tabs to a different domain object and back) Whatever object is returned will be fed back to\n the plugin after the tool state is switch back to the domain object that was active when the this\n method was called.","params":[],"throws":[],"return":{"type_long":"java.lang.Object","comment":"Object to be return in the restoreTransientState() method.","type_short":"Object"}},{"javadoc":"Notification that all plugins have had their data states restored.","static":false,"name":"dataStateRestoreCompleted","comment":"Notification that all plugins have had their data states restored.","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns an object containing the plugin's state as needed to restore itself after an undo\n or redo operation.  Plugins should override this method if they have special undo\/redo handling.\n@param domainObject the object that is about to or has had undoable changes made to it.","static":false,"name":"getUndoRedoState","comment":"Returns an object containing the plugin's state as needed to restore itself after an undo\n or redo operation.  Plugins should override this method if they have special undo\/redo handling.","params":[{"type_long":"ghidra.framework.model.DomainObject","name":"domainObject","comment":"the object that is about to or has had undoable changes made to it.","type_short":"DomainObject"}],"throws":[],"return":{"type_long":"java.lang.Object","comment":"","type_short":"Object"}},{"javadoc":"Updates the plugin's state based on the data stored in the state object.  The state object\n is the object that was returned by this plugin in the {@link #getUndoRedoState(DomainObject)}\n@param domainObject the domain object that has had an undo or redo operation applied to it.\n@param state the state that was recorded before the undo or redo operation.","static":false,"name":"restoreUndoRedoState","comment":"Updates the plugin's state based on the data stored in the state object.  The state object\n is the object that was returned by this plugin in the #getUndoRedoState(DomainObject)","params":[{"type_long":"ghidra.framework.model.DomainObject","name":"domainObject","comment":"the domain object that has had an undo or redo operation applied to it.","type_short":"DomainObject"},{"type_long":"java.lang.Object","name":"state","comment":"the state that was recorded before the undo or redo operation.","type_short":"Object"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns the static {@link PluginDescription} object that was derived from the\n {@link PluginInfo @PluginInfo} annotation at the top of your Plugin.\n <p>\n@return the static\/shared {@link PluginDescription} instance that describes this Plugin.","static":false,"name":"getPluginDescription","comment":"Returns the static PluginDescription object that was derived from the\n PluginInfo annotation at the top of your Plugin.\n ","params":[],"throws":[],"return":{"type_long":"ghidra.framework.plugintool.util.PluginDescription","comment":"the static\/shared PluginDescription instance that describes this Plugin.","type_short":"PluginDescription"}}],"name":"Plugin","comment":"Plugins are a basic building block in Ghidra, used to bundle features or capabilities\n into a unit that can be enabled or disabled by the user in their Tool.\n \n Plugins expose their features or capabilities to users via menu items and buttons that\n the user can click on, and via \"service\" APIs that other Plugins can programmatically subscribe\n to, and via PluginEvents that are broadcast.\n \n Well formed Plugins:\n \n \tDerive from Plugin (directly or indirectly).\n \tClass name ends with \"Plugin\" and does not match any other Plugin, regardless of\n \tits location in the package tree.\n \tHave a PluginInfo annotation.\n \tHave a constructor with exactly 1 parameter: PluginTool.\n \t\t\n  \t\t\tpublic MyPlugin(PluginTool tool) { ... }\n  \t\t\n  \tUsually overrides protected void init().\n \n Class naming\n All Plugin Classes MUST END IN \"Plugin\".  If not, the ClassSearcher will not find them.\n \n Some special Plugins marked with the ProgramaticUseOnly interface are manually\n created and do not follow this naming requirement.\n\n Plugin Life cycle\n \n \tYour Plugin's constructor is called\n \t\t\n \t\t\tPlugin base class constructor is called.\n \t\t\t\t\n \t\t\t\t\tServices listed in the @PluginInfo annotation are automatically added\n \t\t\t\t\tto dependency list\n \t\t\t\t\n \t\t\tYour Plugin publishes any services listed in PluginInfo using\n \t\t\tPlugin#registerServiceProvided(Class, Object).\n \t\t\t(required)\n  \t\t\tCreate Actions (optional)\n  \t\t\tRegister Options with the PluginTool#getOptions(String). (optional)\n \t\t\n \tOther Plugins are constructed, dependencies evaluated, etc.\n \tIf your dependencies are not available (ie. not installed, threw an exception during their\n\tinitialization, etc), your Plugin's #dispose() will be called and then your Plugin\n\tinstance will be discarded.\n\tYour Plugin's #init() method is called (when its dependencies are met).\n \t\t\n \t\t\tCall PluginTool#getService(Class) to get service\n \t\t\timplementations. (the service class being requested should already be\n \t\t\tlisted in the @PluginInfo)\n \t\t\tCreate Actions (optional)\n \t\t\tOther initialization stuff.\n \t\t\n\tYour Plugin's #readConfigState(SaveState) is called.\n \t...user uses Ghidra...\n \t\t\n \t\t\tYour Plugin's #processEvent(PluginEvent) is called for events.\n \t\t\tYour Plugin's Action's methods (ie.\n \t\t\tDockingAction#actionPerformed(docking.ActionContext)) are called.\n \t\t\tYour Plugin's published service methods are called by other Plugins.\n \t\t\tYour Plugin's listener methods are called.\n \t\t\n \tPlugin is unloaded due to shutdown of the Tool or being disabled by user\n \t\t\n\t\t\tYour Plugin's #writeConfigState(SaveState) is called - override this\n\t\t\tmethod to write configuration info into the Tool definition.\n \t\t\tYour Plugin's #dispose() is called - override this method to free\n \t\t\tany resources and perform any needed cleanup.\n \t\t\tYour Plugin's services and events are de-registered automatically.\n \t\t\n \n\n Plugin Service dependency\n All Plugins must be tagged with a PluginInfo annotation.\n \n The annotation gives you the ability to declare a dependency on another Plugin\n via the PluginInfo#servicesRequired() \/\n PluginInfo#servicesUsed()\n \n Ghidra will ensure that your Plugin will not be #init() until all\n of its required services are loaded successfully and are available for use when your Plugin\n calls the PluginTool#getService(Class) method.\n \n Conversely, any services your Plugin advertises in PluginInfo must be published via calls to\n #registerServiceProvided(Class, Object) in your Plugin's constructor.\n \n Cyclic dependencies are not allowed and will cause the Plugin management code to fail to load\n your Plugin. (ie. PluginA requires a service that PluginB provides, which requires a service\n that PluginA provides)\n\n Plugin Service implementation\n A Plugin may provide a service to other Plugins by advertising in its PluginInfo\n annotation that it PluginInfo#servicesProvided() an interface class.\n \n Your Plugin can either directly implement the interface in your Plugin class:\n \n public class MyPlugin extends Plugin implements MyService {....}\n \n or it may delegate the handling of the service interface to another object during its\n constructor:\n \n public MyPlugin(PluginTool tool) {\n ...\n MyService serviceObj = new MyService() { ... };\n registerServiceProvided(MyService.class, serviceObj);\n }\n \n When your Plugin directly implements the advertised service interface, you should not\n call #registerServiceProvided(Class, Object) for that service\n interface.\n \n Service interface classes are just normal java interface declarations and have no\n preconditions or other requirements to be used as a Plugin's advertised service interface.\n \n Optionally, service interface classes can be marked with meta-data via a\n ServiceInfo annotation that can have a\n ServiceInfo#defaultProvider() property which specifies a Plugin's\n class (or classname) that should be auto-loaded to provide an implementation of the service\n interface when that service is required by some other Plugin.  Without the defaultProvider\n information, dependent Plugins will fail to load unless the user manually loads a Plugin\n that provides the necessary interface service.\n \n Multiple Plugins can implement the same service interface.  Plugins that use that\n multi-implemented service will either receive a randomly picked instance if using\n PluginTool#getService(Class) or will receive all implementations if using\n PluginTool#getServices(Class).\n \n\n Plugin Events\n \n \tEvery type of plugin event should be represented by some class extending PluginEvent.\n  One PluginEvent subclass may be used for more than one event type as long as there's some natural grouping.\n \n\n Component Providers\n \n  A plugin may supply a ComponentProvider that provides a visual component when the plugin is added to the tool.\n  TODO - needs more\n \n\n Important interfaces Plugins often need to implement\n \n \tOptionsChangeListener - to receive notification when a configuration option\n \tis changed by the user.\n \tFrontEndable - marks this Plugin as being suitable for inclusion in the FrontEnd tool.\n \tFrontEndOnly - marks this Plugin as FrontEnd only, not usable in CodeBrowser or other tools.\n \tProgramaticUseOnly - marks this Plugin as special and not for user configuration.\n \tTODO\n ","fields":[]}
