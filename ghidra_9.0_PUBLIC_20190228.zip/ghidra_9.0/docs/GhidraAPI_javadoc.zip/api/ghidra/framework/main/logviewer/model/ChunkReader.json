{"implements":[],"javadoc":"This class handles reading data from the input file, in the form of {@link Chunk} objects.  Each\n chunk is stored in the {@link ChunkModel} and represents a single block of text that is \n displayed in the {@link FVTable}.","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"@param file\n@param model\n@throws IOException","static":false,"name":"<init>","comment":"","params":[{"type_long":"java.io.File","name":"file","comment":"","type_short":"File"},{"type_long":"ghidra.framework.main.logviewer.model.ChunkModel","name":"model","comment":"","type_short":"ChunkModel"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns the number of bytes in the input file.\n@return number of bytes\n@throws IOException","static":false,"name":"getFileSize","comment":"Returns the number of bytes in the input file.","params":[],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"long","comment":"number of bytes","type_short":"long"}},{"javadoc":"Returns the file being read.\n@return ","static":false,"name":"getFile","comment":"Returns the file being read.","params":[],"throws":[],"return":{"type_long":"java.io.File","comment":"","type_short":"File"}},{"javadoc":"","static":false,"name":"reload","comment":"","params":[],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Reads one chunk from the end of the file. This is useful when scrolling to the bottom of\n the viewport.\n@return the last chunk, or an empty list\n@throws IOException","static":false,"name":"readLastChunk","comment":"Reads one chunk from the end of the file. This is useful when scrolling to the bottom of\n the viewport.","params":[],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"java.util.List<java.lang.String>","comment":"the last chunk, or an empty list","type_short":"List"}},{"javadoc":"Reads the chunk immediately before the first visible one.\n@return the previous chunk, or an empty list\n@throws IOException","static":false,"name":"readPreviousChunk","comment":"Reads the chunk immediately before the first visible one.","params":[],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"java.util.List<java.lang.String>","comment":"the previous chunk, or an empty list","type_short":"List"}},{"javadoc":"Reads a chunk of data from the given location in the file.  To ensure we're always reading\n full lines, take the given start position and move forward to the next full line before\n reading.\n@param startByte the position to start reading from\n@return the lines of text read\n@throws IOException","static":false,"name":"readNextChunkFrom","comment":"Reads a chunk of data from the given location in the file.  To ensure we're always reading\n full lines, take the given start position and move forward to the next full line before\n reading.","params":[{"type_long":"long","name":"startByte","comment":"the position to start reading from","type_short":"long"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"java.util.List<java.lang.String>","comment":"the lines of text read","type_short":"List"}},{"javadoc":"Reads all bytes from the given byte to the end byte. If the amount of bytes to be read is\n greater than the size of an INT, we will have to read this in several chunks, hence the\n need to return a list of arrays, and not just a single byte array.\n@param startByte\n@param endByte\n@return a map of all the bytes read in (index 0 is first chunk, 1 is next, etc...).\n@throws IOException","static":false,"name":"readBytes","comment":"Reads all bytes from the given byte to the end byte. If the amount of bytes to be read is\n greater than the size of an INT, we will have to read this in several chunks, hence the\n need to return a list of arrays, and not just a single byte array.","params":[{"type_long":"long","name":"startByte","comment":"","type_short":"long"},{"type_long":"long","name":"endByte","comment":"","type_short":"long"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"java.util.List<byte[]>","comment":"a map of all the bytes read in (index 0 is first chunk, 1 is next, etc...).","type_short":"List"}},{"javadoc":"Reads the next chunk in the file past the last one specified in the {@link ChunkModel}.\n@return the lines of text read\n@throws FileNotFoundException\n@throws IOException","static":false,"name":"readNextChunk","comment":"Reads the next chunk in the file past the last one specified in the ChunkModel.","params":[],"throws":[{"type_long":"java.io.FileNotFoundException","comment":"","type_short":"FileNotFoundException"},{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"java.util.List<java.lang.String>","comment":"the lines of text read","type_short":"List"}},{"javadoc":"Returns the start of the next line after the given byte. To do this, simply read \n backwards from the given point until a newline or carriage return is found.\n@param startByte\n@return \n@throws IOException","static":false,"name":"getStartOfNextLine","comment":"Returns the start of the next line after the given byte. To do this, simply read \n backwards from the given point until a newline or carriage return is found.","params":[{"type_long":"long","name":"startByte","comment":"","type_short":"long"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"long","comment":"","type_short":"long"}}],"name":"ChunkReader","comment":"This class handles reading data from the input file, in the form of Chunk objects.  Each\n chunk is stored in the ChunkModel and represents a single block of text that is \n displayed in the FVTable.","fields":[]}
