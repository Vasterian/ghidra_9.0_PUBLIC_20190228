{"implements":[],"javadoc":"A dummy action that allows key bindings to be edited through the key bindings options\n <b>without<\/b> requiring the user to implement a system action that will be added to the tool.\n Without this class the only editable tool key bindings are those that have corresponding\n {@link DockingAction}s added to the tool.\n <p>\n A typical usage of this class: Suppose a plugin has an action that it adds to the tool, \n which is logically the same action (with the same name) that a second plugin adds to the tool.  \n Both of these actions are \n logically equivalent and share the same default key binding.  Since these actions are \n logically the same, then they should share the same key binding and only have one entry \n in the key binding options, instead of two.  This class enables both actions to have key \n bindings assigned via one dummy action.  <b>To do this each of the above primary actions will set \n themselves to not manage key bindings<\/b>, so they don't appear in the key bindings options,  \n and will then create an instance of this class and register it with the tool.  Then, each of \n those primary actions will listen for options changes to know when the user has edited\n the key binding of the dummy action.  The following snippet is an example of this usage,\n taken from the constructor of a DockingAction:\n <pre>\n       \/\/ setup key binding management\n       setKeyBindingManaged( false ); \/\/ our dummy will handle this task, not us\n       KeyStroke keyStroke = ...;\n       PluginTool tool = plugin.getTool();\n       tool.addAction( new DummyKeyBindingsOptionsAction( ACTION_NAME, keyStroke ) );\n       \n       \/\/ setup options to know when the dummy key binding is changed\n       Options options = tool.getOptions(ToolConstants.KEY_BINDINGS);        \n       KeyStroke optionsKeyStroke = options.getKeyStroke( \"Tool\", ACTION_NAME, keyStroke );\n       \n       if (!keyStroke(optionsKeyStroke)) {\n           \/\/ user-defined keystroke\n           setUnvalidatedKeyBindingData(new KeyBindingData(keyStroke));\n       }\n       else {\n           setKeyBindingData(new KeyBindingData(keyStroke));\n       }\n\n       options.addOptionsChangeListener( ... );\n <\/pre>\n \n And for changes to the options keybinding value:\n <pre>\n  public void optionsChanged(Options options, String name, Object oldValue, Object newValue) {\n      KeyStroke keyStroke = (KeyStroke) newValue;\n      if (name.startsWith(KEY_BINDING_NAME)) {\n          setUnvalidatedKeyBindingData(new KeyBindingData(keyStroke));\n      }\n  }\n <\/pre>","static":false,"extends":"docking.action.DockingAction","methods":[{"javadoc":"Creates a new dummy action by the given name and default keystroke value.\n@param name The name of the action--this will be displayed in the options as the name of\n             key binding's action.\n@param defaultKeyStroke The default keystroke value for this action.  This value may be null.","static":false,"name":"<init>","comment":"Creates a new dummy action by the given name and default keystroke value.","params":[{"type_long":"java.lang.String","name":"name","comment":"The name of the action--this will be displayed in the options as the name of\n             key binding's action.","type_short":"String"},{"type_long":"javax.swing.KeyStroke","name":"defaultKeyStroke","comment":"The default keystroke value for this action.  This value may be null.","type_short":"KeyStroke"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"actionPerformed","comment":"","params":[{"type_long":"docking.ActionContext","name":"context","comment":"","type_short":"ActionContext"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"isAddToPopup","comment":"","params":[{"type_long":"docking.ActionContext","name":"context","comment":"","type_short":"ActionContext"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":false,"name":"isEnabledForContext","comment":"","params":[{"type_long":"docking.ActionContext","name":"context","comment":"","type_short":"ActionContext"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}}],"name":"DummyKeyBindingsOptionsAction","comment":"A dummy action that allows key bindings to be edited through the key bindings options\n without requiring the user to implement a system action that will be added to the tool.\n Without this class the only editable tool key bindings are those that have corresponding\n DockingActions added to the tool.\n \n A typical usage of this class: Suppose a plugin has an action that it adds to the tool, \n which is logically the same action (with the same name) that a second plugin adds to the tool.  \n Both of these actions are \n logically equivalent and share the same default key binding.  Since these actions are \n logically the same, then they should share the same key binding and only have one entry \n in the key binding options, instead of two.  This class enables both actions to have key \n bindings assigned via one dummy action.  To do this each of the above primary actions will set \n themselves to not manage key bindings, so they don't appear in the key bindings options,  \n and will then create an instance of this class and register it with the tool.  Then, each of \n those primary actions will listen for options changes to know when the user has edited\n the key binding of the dummy action.  The following snippet is an example of this usage,\n taken from the constructor of a DockingAction:\n \n       \/\/ setup key binding management\n       setKeyBindingManaged( false ); \/\/ our dummy will handle this task, not us\n       KeyStroke keyStroke = ...;\n       PluginTool tool = plugin.getTool();\n       tool.addAction( new DummyKeyBindingsOptionsAction( ACTION_NAME, keyStroke ) );\n       \n       \/\/ setup options to know when the dummy key binding is changed\n       Options options = tool.getOptions(ToolConstants.KEY_BINDINGS);        \n       KeyStroke optionsKeyStroke = options.getKeyStroke( \"Tool\", ACTION_NAME, keyStroke );\n       \n       if (!keyStroke(optionsKeyStroke)) {\n           \/\/ user-defined keystroke\n           setUnvalidatedKeyBindingData(new KeyBindingData(keyStroke));\n       }\n       else {\n           setKeyBindingData(new KeyBindingData(keyStroke));\n       }\n\n       options.addOptionsChangeListener( ... );\n \n \n And for changes to the options keybinding value:\n \n  public void optionsChanged(Options options, String name, Object oldValue, Object newValue) {\n      KeyStroke keyStroke = (KeyStroke) newValue;\n      if (name.startsWith(KEY_BINDING_NAME)) {\n          setUnvalidatedKeyBindingData(new KeyBindingData(keyStroke));\n      }\n  }\n ","fields":[{"type_long":"java.lang.String","javadoc":"","static":true,"name":"DEFAULT_OWNER","comment":"","type_short":"String","constant_value":"\"Tool\""}]}
