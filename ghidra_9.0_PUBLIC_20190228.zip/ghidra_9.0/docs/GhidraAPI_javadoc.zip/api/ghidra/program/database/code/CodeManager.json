{"implements":["db.util.ErrorHandler","ghidra.program.database.ManagerDB"],"javadoc":"Class to manage database tables for data and instructions.","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"Constructs a new CodeManager for a program.\n@param handle handle to database\n@param addrMap addressMap to convert between addresses and long values.\n@param openMode either READ_ONLY, UPDATE, or UPGRADE\n@param lock the program synchronization lock\n@param monitor the task monitor use while upgrading.\n@throws VersionException if the database is incompatible with the current\n schema\n@throws IOException if a database io error occurs\n@throws CancelledException if the user cancels the upgrade operation","static":false,"name":"<init>","comment":"Constructs a new CodeManager for a program.","params":[{"type_long":"db.DBHandle","name":"handle","comment":"handle to database","type_short":"DBHandle"},{"type_long":"ghidra.program.database.map.AddressMap","name":"addrMap","comment":"addressMap to convert between addresses and long values.","type_short":"AddressMap"},{"type_long":"int","name":"openMode","comment":"either READ_ONLY, UPDATE, or UPGRADE","type_short":"int"},{"type_long":"ghidra.util.Lock","name":"lock","comment":"the program synchronization lock","type_short":"Lock"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor use while upgrading.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.VersionException","comment":"if the database is incompatible with the current\n schema","type_short":"VersionException"},{"type_long":"ghidra.util.exception.CancelledException","comment":"if the user cancels the upgrade operation","type_short":"CancelledException"},{"type_long":"java.io.IOException","comment":"if a database io error occurs","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Set the program after all the managers have been created.\n@param program The program object that this manager belongs to.","static":false,"name":"setProgram","comment":"Set the program after all the managers have been created.","params":[{"type_long":"ghidra.program.database.ProgramDB","name":"program","comment":"The program object that this manager belongs to.","type_short":"ProgramDB"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"@see ghidra.program.database.ManagerDB#programReady(int, int, ghidra.util.task.TaskMonitor)","static":false,"name":"programReady","comment":"","params":[{"type_long":"int","name":"openMode","comment":"","type_short":"int"},{"type_long":"int","name":"currentRevision","comment":"","type_short":"int"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"},{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"activateContextLocking","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"@see db.util.ErrorHandler#dbError(java.io.IOException)","static":false,"name":"dbError","comment":"","params":[{"type_long":"java.io.IOException","name":"e","comment":"","type_short":"IOException"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Creates a complete set of instructions.\n A preliminary pass will be made checking for code unit conflicts which will be\n marked within the instructionSet causing dependent blocks to get pruned.\n@param instructionSet the set of instructions to be added.  All code unit conflicts\n will be marked within the instructionSet and associated blocks.\n@throws CodeUnitInsertionException if the instruction set is incompatible\n with the program memory","static":false,"name":"addInstructions","comment":"Creates a complete set of instructions.\n A preliminary pass will be made checking for code unit conflicts which will be\n marked within the instructionSet causing dependent blocks to get pruned.","params":[{"type_long":"ghidra.program.model.lang.InstructionSet","name":"instructionSet","comment":"the set of instructions to be added.  All code unit conflicts\n will be marked within the instructionSet and associated blocks.","type_short":"InstructionSet"},{"type_long":"boolean","name":"overwrite","comment":"","type_short":"boolean"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.AddressSetView","comment":"","type_short":"AddressSetView"}},{"javadoc":"Creates an instruction at the specified address.\n@param address start address of instruction\n@param prototype instruction definition object\n@param memBuf the MemBuffer to use to get the bytes from memory\n@param context object that has the state of all the registers.\n@exception CodeUnitInsertionException thrown if code unit\n                  overlaps with an existing code unit","static":false,"name":"createCodeUnit","comment":"Creates an instruction at the specified address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"start address of instruction","type_short":"Address"},{"type_long":"ghidra.program.model.lang.InstructionPrototype","name":"prototype","comment":"instruction definition object","type_short":"InstructionPrototype"},{"type_long":"ghidra.program.model.mem.MemBuffer","name":"memBuf","comment":"the MemBuffer to use to get the bytes from memory","type_short":"MemBuffer"},{"type_long":"ghidra.program.model.lang.ProcessorContextView","name":"context","comment":"object that has the state of all the registers.","type_short":"ProcessorContextView"}],"throws":[{"type_long":"ghidra.program.model.util.CodeUnitInsertionException","comment":"","type_short":"CodeUnitInsertionException"}],"return":{"type_long":"ghidra.program.model.listing.Instruction","comment":"","type_short":"Instruction"}},{"javadoc":"Removes the block of defined bytes from the listing. All necessary checks will\n be made by listing before this method is called, so just do the work.\n@param start the first address in the range.\n@param end the last address in the range.\n@param monitor the TaskMonitor that tracks progress and is used to tell\n if the user cancels the operation.\n@throws CancelledExeption if the user cancels the operation.","static":false,"name":"deleteAddressRange","comment":"Removes the block of defined bytes from the listing. All necessary checks will\n be made by listing before this method is called, so just do the work.","params":[{"type_long":"ghidra.program.model.address.Address","name":"start","comment":"the first address in the range.","type_short":"Address"},{"type_long":"ghidra.program.model.address.Address","name":"end","comment":"the last address in the range.","type_short":"Address"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the TaskMonitor that tracks progress and is used to tell\n if the user cancels the operation.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Move a block of code from one address to a new address.\n Updates all property managers, symbols, and references.\n@param fromAddr the first address in the range to be moved.\n@param toAddr the address to move to.\n@param length the number of addresses to move.\n@param monitor the TaskMonitor that tracks progress and is used to tell\n if the user cancels the operation.\n@throws CancelledExeption if the user cancels the operation.","static":false,"name":"moveAddressRange","comment":"Move a block of code from one address to a new address.\n Updates all property managers, symbols, and references.","params":[{"type_long":"ghidra.program.model.address.Address","name":"fromAddr","comment":"the first address in the range to be moved.","type_short":"Address"},{"type_long":"ghidra.program.model.address.Address","name":"toAddr","comment":"the address to move to.","type_short":"Address"},{"type_long":"long","name":"length","comment":"the number of addresses to move.","type_short":"long"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the TaskMonitor that tracks progress and is used to tell\n if the user cancels the operation.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns the code unit whose min address equals\n the specified address.\n@param address the min address of the code unit to return\n@return CodeUnit the code unit at the specified address,\n                  or null if a code unit does not exist","static":false,"name":"getCodeUnitAt","comment":"Returns the code unit whose min address equals\n the specified address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the min address of the code unit to return","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.CodeUnit","comment":"CodeUnit the code unit at the specified address,\n                  or null if a code unit does not exist","type_short":"CodeUnit"}},{"javadoc":"Returns the next code unit whose min address is greater\n than the specified address.\n@param addr the address to look after\n@return CodeUnit the code unit after the specified address,\n                  or null if a code unit does not exist","static":false,"name":"getCodeUnitAfter","comment":"Returns the next code unit whose min address is greater\n than the specified address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the address to look after","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.CodeUnit","comment":"CodeUnit the code unit after the specified address,\n                  or null if a code unit does not exist","type_short":"CodeUnit"}},{"javadoc":"Returns an iterator over all user-defined properties.\n@return Iterator an iterator over all user-defined properties","static":false,"name":"getUserDefinedProperties","comment":"Returns an iterator over all user-defined properties.","params":[],"throws":[],"return":{"type_long":"java.util.Iterator<java.lang.String>","comment":"Iterator an iterator over all user-defined properties","type_short":"Iterator"}},{"javadoc":"Removes the user-defined property with the\n specified property name.\n@param propertyName the name of the user-defined property to remove","static":false,"name":"removeUserDefinedProperty","comment":"Removes the user-defined property with the\n specified property name.","params":[{"type_long":"java.lang.String","name":"propertyName","comment":"the name of the user-defined property to remove","type_short":"String"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns the property map object that is associated\n with the specified property name.\n@param propertyName the name of the property\n@return PropertyMap  the property map object associated to the property name","static":false,"name":"getPropertyMap","comment":"Returns the property map object that is associated\n with the specified property name.","params":[{"type_long":"java.lang.String","name":"propertyName","comment":"the name of the property","type_short":"String"}],"throws":[],"return":{"type_long":"ghidra.program.model.util.PropertyMap","comment":"PropertyMap  the property map object associated to the property name","type_short":"PropertyMap"}},{"javadoc":"Returns the next code unit whose min address is\n closest to and less than the specified address.\n@param address the address to look before\n@return CodeUnit the code unit before the specified address,\n                  or null if a code unit does not exist","static":false,"name":"getCodeUnitBefore","comment":"Returns the next code unit whose min address is\n closest to and less than the specified address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address to look before","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.CodeUnit","comment":"CodeUnit the code unit before the specified address,\n                  or null if a code unit does not exist","type_short":"CodeUnit"}},{"javadoc":"Returns the code unit whose min address is less than\n or equal to the specified address and whose max address\n is greater than or equal to the specified address.\n <pre>\n codeunit.minAddress() <= addr <= codeunit.maxAddress()\n <\/pre>\n@param address the address for which to find the code containing it.\n@return CodeUnit the code unit containing the specified address,\n                  or null if a code unit does not exist","static":false,"name":"getCodeUnitContaining","comment":"Returns the code unit whose min address is less than\n or equal to the specified address and whose max address\n is greater than or equal to the specified address.\n \n codeunit.minAddress() = addr = codeunit.maxAddress()\n ","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address for which to find the code containing it.","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.CodeUnit","comment":"CodeUnit the code unit containing the specified address,\n                  or null if a code unit does not exist","type_short":"CodeUnit"}},{"javadoc":"Get an iterator that contains the code units which have the specified\n property type defined. Only code units at an address greater than or\n equal to the specified start address will be returned by the iterator.\n If the start address is null then check the entire program.\n <br>\n Standard property types are defined in the CodeUnit class.\n The property types are:\n          <ul>\n              <li>COMMENT_PROPERTY<\/li>\n              <li>INSTRUCTION_PROPERTY<\/li>\n              <li>DEFINED_DATA_PROPERTY<\/li>\n          <\/ul>\n Property types can also be user defined.\n@param property the name of the user defined property type or special standard name from above.\n@param address the address to start the iterator, or null to iterator the entire program\n@param forward true means get iterator in the forward direction\n@return a CodeUnitIterator that returns all code units from the indicated\n         start address that have the specified property type defined.","static":false,"name":"getCodeUnitIterator","comment":"Get an iterator that contains the code units which have the specified\n property type defined. Only code units at an address greater than or\n equal to the specified start address will be returned by the iterator.\n If the start address is null then check the entire program.\n \n Standard property types are defined in the CodeUnit class.\n The property types are:\n          \n              COMMENT_PROPERTY\n              INSTRUCTION_PROPERTY\n              DEFINED_DATA_PROPERTY\n          \n Property types can also be user defined.","params":[{"type_long":"java.lang.String","name":"property","comment":"the name of the user defined property type or special standard name from above.","type_short":"String"},{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address to start the iterator, or null to iterator the entire program","type_short":"Address"},{"type_long":"boolean","name":"forward","comment":"true means get iterator in the forward direction","type_short":"boolean"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.CodeUnitIterator","comment":"a CodeUnitIterator that returns all code units from the indicated\n         start address that have the specified property type defined.","type_short":"CodeUnitIterator"}},{"javadoc":"Get an iterator that contains the code units which have the specified\n property type defined. Only code units starting within the address set\n specified will be returned by the iterator.\n If the address set is null then check the entire program.\n <br>\n Standard property types are defined in the CodeUnit class.\n The property types are:\n          <ul>\n              <li>REFERENCE_PROPERTY<\/li>\n              <li>INSTRUCTION_PROPERTY<\/li>\n              <li>DEFINED_DATA_PROPERTY<\/li>\n          <\/ul>\n Property types can also be user defined.\n@param property the name of the property type, or this can be user defined.\n@param addrSetView the address set to iterate, or null to iterate over the entire program\n@param forward true means the iterator is in the forward direction\n@return a CodeUnitIterator that returns all code units from the indicated\n         address set that have the specified property type defined.","static":false,"name":"getCodeUnitIterator","comment":"Get an iterator that contains the code units which have the specified\n property type defined. Only code units starting within the address set\n specified will be returned by the iterator.\n If the address set is null then check the entire program.\n \n Standard property types are defined in the CodeUnit class.\n The property types are:\n          \n              REFERENCE_PROPERTY\n              INSTRUCTION_PROPERTY\n              DEFINED_DATA_PROPERTY\n          \n Property types can also be user defined.","params":[{"type_long":"java.lang.String","name":"property","comment":"the name of the property type, or this can be user defined.","type_short":"String"},{"type_long":"ghidra.program.model.address.AddressSetView","name":"addrSetView","comment":"the address set to iterate, or null to iterate over the entire program","type_short":"AddressSetView"},{"type_long":"boolean","name":"forward","comment":"true means the iterator is in the forward direction","type_short":"boolean"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.CodeUnitIterator","comment":"a CodeUnitIterator that returns all code units from the indicated\n         address set that have the specified property type defined.","type_short":"CodeUnitIterator"}},{"javadoc":"Get a forward iterator over code units that have comments of the given type.\n@param commentType comment type defined in CodeUnit\n@param set address set","static":false,"name":"getCommentCodeUnitIterator","comment":"Get a forward iterator over code units that have comments of the given type.","params":[{"type_long":"int","name":"commentType","comment":"comment type defined in CodeUnit","type_short":"int"},{"type_long":"ghidra.program.model.address.AddressSetView","name":"set","comment":"address set","type_short":"AddressSetView"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.CodeUnitIterator","comment":"","type_short":"CodeUnitIterator"}},{"javadoc":"Get a forward iterator over addresses that have comments of the given type.\n@param commentType comment type defined in CodeUnit\n@param set address set","static":false,"name":"getCommentAddressIterator","comment":"Get a forward iterator over addresses that have comments of the given type.","params":[{"type_long":"int","name":"commentType","comment":"comment type defined in CodeUnit","type_short":"int"},{"type_long":"ghidra.program.model.address.AddressSetView","name":"set","comment":"address set","type_short":"AddressSetView"},{"type_long":"boolean","name":"forward","comment":"","type_short":"boolean"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.AddressIterator","comment":"","type_short":"AddressIterator"}},{"javadoc":"Get a forward iterator over addresses that have comments of any type.\n@param set address set","static":false,"name":"getCommentAddressIterator","comment":"Get a forward iterator over addresses that have comments of any type.","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"addrSet","comment":"","type_short":"AddressSetView"},{"type_long":"boolean","name":"forward","comment":"","type_short":"boolean"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.AddressIterator","comment":"","type_short":"AddressIterator"}},{"javadoc":"Returns the instruction whose min address equals\n the specified address or null if the address is not the beginning address\n of some codeunit.\n@param address the min address of the instruction to return\n@return CodeUnit the instruction at the specified address,\n                  or null if a instruction does not exist starting at the\n \t\t\t\t    given address.","static":false,"name":"getInstructionAt","comment":"Returns the instruction whose min address equals\n the specified address or null if the address is not the beginning address\n of some codeunit.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the min address of the instruction to return","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Instruction","comment":"CodeUnit the instruction at the specified address,\n                  or null if a instruction does not exist starting at the\n \t\t\t\t    given address.","type_short":"Instruction"}},{"javadoc":"Returns the defined data whose min address equals\n the specified address.\n@param address the min address of the data defined to return\n@return CodeUnit the defined data at the specified address,\n                  or null if a defined data does not exist","static":false,"name":"getDefinedDataAt","comment":"Returns the defined data whose min address equals\n the specified address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the min address of the data defined to return","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Data","comment":"CodeUnit the defined data at the specified address,\n                  or null if a defined data does not exist","type_short":"Data"}},{"javadoc":"Returns the next instruction whose min address is\n closest to and less than the specified address.\n@param addr the address to look before\n@return Instruction the instruction before the specified address,\n                  or null if a instruction does not exist","static":false,"name":"getInstructionBefore","comment":"Returns the next instruction whose min address is\n closest to and less than the specified address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the address to look before","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Instruction","comment":"Instruction the instruction before the specified address,\n                  or null if a instruction does not exist","type_short":"Instruction"}},{"javadoc":"Returns the next instruction whose min address is greater\n than the specified address.\n@param addr the address to look after\n@return Instruction the instruction after the specified address,\n                  or null if a instruction does not exist","static":false,"name":"getInstructionAfter","comment":"Returns the next instruction whose min address is greater\n than the specified address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the address to look after","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Instruction","comment":"Instruction the instruction after the specified address,\n                  or null if a instruction does not exist","type_short":"Instruction"}},{"javadoc":"Returns the instruction whose min address is less than\n or equal to the specified address and whose max address\n is greater than or equal to the specified address.\n <pre>\n instruction.minAddress() <= addr <= instruction.maxAddress()\n <\/pre>\n@param address the address to be contained\n@return Instruction the instruction containing the specified address,\n                  or null if a instruction does not exist","static":false,"name":"getInstructionContaining","comment":"Returns the instruction whose min address is less than\n or equal to the specified address and whose max address\n is greater than or equal to the specified address.\n \n instruction.minAddress() = addr = instruction.maxAddress()\n ","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address to be contained","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Instruction","comment":"Instruction the instruction containing the specified address,\n                  or null if a instruction does not exist","type_short":"Instruction"}},{"javadoc":"Returns the data whose min address equals\n the specified address.\n@param address the min address of the data to return\n@return Data the data at the specified address,\n                  or null if data does not exist","static":false,"name":"getDataAt","comment":"Returns the data whose min address equals\n the specified address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the min address of the data to return","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Data","comment":"Data the data at the specified address,\n                  or null if data does not exist","type_short":"Data"}},{"javadoc":"Returns the next data whose min address is\n closest to and less than the specified address.\n@param addr the address to look before\n@return Data the data before the specified address,\n                  or null if a data does not exist","static":false,"name":"getDataBefore","comment":"Returns the next data whose min address is\n closest to and less than the specified address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the address to look before","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Data","comment":"Data the data before the specified address,\n                  or null if a data does not exist","type_short":"Data"}},{"javadoc":"Returns the next data whose min address is greater\n than the specified address.\n@param addr the address to look after\n@return Data the data after the specified address,\n                  or null if a data does not exist","static":false,"name":"getDataAfter","comment":"Returns the next data whose min address is greater\n than the specified address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the address to look after","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Data","comment":"Data the data after the specified address,\n                  or null if a data does not exist","type_short":"Data"}},{"javadoc":"Returns the data whose min address is less than\n or equal to the specified address and whose max address\n is greater than or equal to the specified address.\n <pre>\n data.minAddress() <= addr <= data.maxAddress()\n <\/pre>\n@param addr the address to be contained\n@return Data the data containing the specified address,\n                  or null if a data does not exist that starts at that\n \t\t\t\t    address.","static":false,"name":"getDataContaining","comment":"Returns the data whose min address is less than\n or equal to the specified address and whose max address\n is greater than or equal to the specified address.\n \n data.minAddress() = addr = data.maxAddress()\n ","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the address to be contained","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Data","comment":"Data the data containing the specified address,\n                  or null if a data does not exist that starts at that\n \t\t\t\t    address.","type_short":"Data"}},{"javadoc":"Returns the next defined data whose min address is greater\n than the specified address.\n@param addr the address to look after\n@return Data the defined data after the specified address,\n                  or null if a defined data does not exist","static":false,"name":"getDefinedDataAfter","comment":"Returns the next defined data whose min address is greater\n than the specified address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the address to look after","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Data","comment":"Data the defined data after the specified address,\n                  or null if a defined data does not exist","type_short":"Data"}},{"javadoc":"Returns the next defined data whose min address is\n closest to and less than the specified address.\n@param addr the address to look before\n@return Data the defined data before the specified address,\n                  or null if a defined data does not exist","static":false,"name":"getDefinedDataBefore","comment":"Returns the next defined data whose min address is\n closest to and less than the specified address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the address to look before","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Data","comment":"Data the defined data before the specified address,\n                  or null if a defined data does not exist","type_short":"Data"}},{"javadoc":"Returns the defined data whose min address is less than\n or equal to the specified address and whose max address\n is greater than or equal to the specified address.\n <pre>\n data.minAddress() <= addr <= data.maxAddress()\n <\/pre>\n@param addr the address to be contained\n@return Data the defined data containing the specified address,\n                  or null if a defined data does not exist","static":false,"name":"getDefinedDataContaining","comment":"Returns the defined data whose min address is less than\n or equal to the specified address and whose max address\n is greater than or equal to the specified address.\n \n data.minAddress() = addr = data.maxAddress()\n ","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the address to be contained","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Data","comment":"Data the defined data containing the specified address,\n                  or null if a defined data does not exist","type_short":"Data"}},{"javadoc":"","static":false,"name":"getUndefinedRanges","comment":"","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"set","comment":"","type_short":"AddressSetView"},{"type_long":"boolean","name":"initializedMemoryOnly","comment":"","type_short":"boolean"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"ghidra.program.model.address.AddressSetView","comment":"","type_short":"AddressSetView"}},{"javadoc":"Returns the undefined data whose min address equals\n the specified address.\n@param address the min address of the undefined data to return\n@return Data the undefined data at the specified address,\n                  or null if undefined data does not exist","static":false,"name":"getUndefinedAt","comment":"Returns the undefined data whose min address equals\n the specified address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the min address of the undefined data to return","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Data","comment":"Data the undefined data at the specified address,\n                  or null if undefined data does not exist","type_short":"Data"}},{"javadoc":"Returns the next undefined data whose min address is greater\n than the specified address.\n@param addr the address to look after\n@return Data the undefined data after the specified address,\n                  or null if a undefined data does not exist","static":false,"name":"getFirstUndefinedDataAfter","comment":"Returns the next undefined data whose min address is greater\n than the specified address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the address to look after","type_short":"Address"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Data","comment":"Data the undefined data after the specified address,\n                  or null if a undefined data does not exist","type_short":"Data"}},{"javadoc":"Returns the next undefined data whose min address falls within the address set\n searching in the forward direction (e.g., 0 -> 0xfff).\n@param addrSet the address Set to look within\n@return Data the first undefined data within the address set, or null if there is none.","static":false,"name":"getFirstUndefinedData","comment":"Returns the next undefined data whose min address falls within the address set\n searching in the forward direction (e.g., 0 - 0xfff).","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"set","comment":"","type_short":"AddressSetView"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Data","comment":"Data the first undefined data within the address set, or null if there is none.","type_short":"Data"}},{"javadoc":"Returns the next undefined data whose min address is\n closest to and less than the specified address.\n@param addr the address to look before\n@return Data the undefined data before the specified address,\n                  or null if a undefined data does not exist","static":false,"name":"getFirstUndefinedDataBefore","comment":"Returns the next undefined data whose min address is\n closest to and less than the specified address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the address to look before","type_short":"Address"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Data","comment":"Data the undefined data before the specified address,\n                  or null if a undefined data does not exist","type_short":"Data"}},{"javadoc":"Creates a data at the specified address.\n@param addr Starting address of code unit\n@param dataType data prototype for the code unit\n@exception CodeUnitInsertionException thrown if code unit overlaps with an existing code unit","static":false,"name":"createCodeUnit","comment":"Creates a data at the specified address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"Starting address of code unit","type_short":"Address"},{"type_long":"ghidra.program.model.data.DataType","name":"dataType","comment":"data prototype for the code unit","type_short":"DataType"},{"type_long":"int","name":"length","comment":"","type_short":"int"}],"throws":[{"type_long":"ghidra.program.model.util.CodeUnitInsertionException","comment":"","type_short":"CodeUnitInsertionException"}],"return":{"type_long":"ghidra.program.model.listing.Data","comment":"","type_short":"Data"}},{"javadoc":"Update the data references on this data item.\n Get rid of any references first, then add in any new ones.\n@param data the data object to be updated","static":false,"name":"updateDataReferences","comment":"Update the data references on this data item.\n Get rid of any references first, then add in any new ones.","params":[{"type_long":"ghidra.program.model.listing.Data","name":"data","comment":"the data object to be updated","type_short":"Data"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Clears all comments in the given range (inclusive).\n@param start the start address of the range to clear\n@param end the end   address of the range to clear","static":false,"name":"clearComments","comment":"Clears all comments in the given range (inclusive).","params":[{"type_long":"ghidra.program.model.address.Address","name":"start","comment":"the start address of the range to clear","type_short":"Address"},{"type_long":"ghidra.program.model.address.Address","name":"end","comment":"the end   address of the range to clear","type_short":"Address"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Clears the properties in the given range (inclusive).\n@param start the start address of the range to clear\n@param end the end   address of the range to clear","static":false,"name":"clearProperties","comment":"Clears the properties in the given range (inclusive).","params":[{"type_long":"ghidra.program.model.address.Address","name":"start","comment":"the start address of the range to clear","type_short":"Address"},{"type_long":"ghidra.program.model.address.Address","name":"end","comment":"the end   address of the range to clear","type_short":"Address"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Remove code units, symbols, equates, and references to\n code units in the given range (inclusive).  Comments\n and comment history will be retained.\n@param start the start address of the range to clear\n@param end the end   address of the range to clear\n@param clearContext if true all context-register values will be cleared over range\n@param monitor the TaskMonitor that tracks progress and is used to tell\n if the user cancels the operation.","static":false,"name":"clearCodeUnits","comment":"Remove code units, symbols, equates, and references to\n code units in the given range (inclusive).  Comments\n and comment history will be retained.","params":[{"type_long":"ghidra.program.model.address.Address","name":"start","comment":"the start address of the range to clear","type_short":"Address"},{"type_long":"ghidra.program.model.address.Address","name":"end","comment":"the end   address of the range to clear","type_short":"Address"},{"type_long":"boolean","name":"clearContext","comment":"if true all context-register values will be cleared over range","type_short":"boolean"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the TaskMonitor that tracks progress and is used to tell\n if the user cancels the operation.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Clear all code units in the program.","static":false,"name":"clearAll","comment":"Clear all code units in the program.","params":[{"type_long":"boolean","name":"clearContext","comment":"","type_short":"boolean"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns the number of instructions in the program.","static":false,"name":"getNumInstructions","comment":"Returns the number of instructions in the program.","params":[],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"Returns the number of defined data in the program.","static":false,"name":"getNumDefinedData","comment":"Returns the number of defined data in the program.","params":[],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"Returns a composite data iterator beginning at the specified\n start address.\n@param start the address to begin iterator\n@param forward true means get iterator in forward direction\n@return DataIterator the composite data iterator","static":false,"name":"getCompositeData","comment":"Returns a composite data iterator beginning at the specified\n start address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"start","comment":"the address to begin iterator","type_short":"Address"},{"type_long":"boolean","name":"forward","comment":"true means get iterator in forward direction","type_short":"boolean"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.DataIterator","comment":"DataIterator the composite data iterator","type_short":"DataIterator"}},{"javadoc":"Returns a composite data iterator limited to the addresses\n in the specified address set.\n@param addrSet the address set to limit the iterator\n@param forward determines if the iterator will go from the lowest address to\n the highest or the other way around.\n@return DataIterator the composite data iterator","static":false,"name":"getCompositeData","comment":"Returns a composite data iterator limited to the addresses\n in the specified address set.","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"addrSet","comment":"the address set to limit the iterator","type_short":"AddressSetView"},{"type_long":"boolean","name":"forward","comment":"determines if the iterator will go from the lowest address to\n the highest or the other way around.","type_short":"boolean"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.DataIterator","comment":"DataIterator the composite data iterator","type_short":"DataIterator"}},{"javadoc":"Returns an iterator over all codeUnits in the program from the given\n start address to either the end address or the start address, depending if\n the iterator is forward or not.\n@param start the starting address for the iterator.\n@param forward if true the iterator returns all codeUnits from the given\n start address to the end of the program, otherwise it returns all codeUnits\n from the given start address to the start of the program.","static":false,"name":"getCodeUnits","comment":"Returns an iterator over all codeUnits in the program from the given\n start address to either the end address or the start address, depending if\n the iterator is forward or not.","params":[{"type_long":"ghidra.program.model.address.Address","name":"start","comment":"the starting address for the iterator.","type_short":"Address"},{"type_long":"boolean","name":"forward","comment":"if true the iterator returns all codeUnits from the given\n start address to the end of the program, otherwise it returns all codeUnits\n from the given start address to the start of the program.","type_short":"boolean"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.CodeUnitIterator","comment":"","type_short":"CodeUnitIterator"}},{"javadoc":"Returns an iterator over all codeUnits in the given addressSet. The iterator\n will go from the lowest address to the largest or from the largest to the\n lowest depending on the forward parameter.\n@param forward determines if the iterator goes from lowest address to highest\n or the other way around.","static":false,"name":"getCodeUnits","comment":"Returns an iterator over all codeUnits in the given addressSet. The iterator\n will go from the lowest address to the largest or from the largest to the\n lowest depending on the forward parameter.","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"set","comment":"","type_short":"AddressSetView"},{"type_long":"boolean","name":"forward","comment":"determines if the iterator goes from lowest address to highest\n or the other way around.","type_short":"boolean"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.CodeUnitIterator","comment":"","type_short":"CodeUnitIterator"}},{"javadoc":"Returns an iterator over all instructions in the program from the given\n start address to either the end address or the start address, depending if\n the iterator is forward or not.\n@param address the starting address for the iterator.\n@param forward if true the iterator returns all instructions from the given\n start address to the end of the program, otherwise it returns all instructions\n from the given start address to the start of the program.","static":false,"name":"getInstructions","comment":"Returns an iterator over all instructions in the program from the given\n start address to either the end address or the start address, depending if\n the iterator is forward or not.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the starting address for the iterator.","type_short":"Address"},{"type_long":"boolean","name":"forward","comment":"if true the iterator returns all instructions from the given\n start address to the end of the program, otherwise it returns all instructions\n from the given start address to the start of the program.","type_short":"boolean"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.InstructionIterator","comment":"","type_short":"InstructionIterator"}},{"javadoc":"Returns an iterator over all defined data in the program from the given\n start address to either the end address or the start address, depending if\n the iterator is forward or not.\n@param address the starting address for the iterator.\n@param forward if true the iterator returns all defined data from the given\n start address to the end of the program, otherwise it returns all defined data\n from the given start address to the start of the program.","static":false,"name":"getDefinedData","comment":"Returns an iterator over all defined data in the program from the given\n start address to either the end address or the start address, depending if\n the iterator is forward or not.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the starting address for the iterator.","type_short":"Address"},{"type_long":"boolean","name":"forward","comment":"if true the iterator returns all defined data from the given\n start address to the end of the program, otherwise it returns all defined data\n from the given start address to the start of the program.","type_short":"boolean"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.DataIterator","comment":"","type_short":"DataIterator"}},{"javadoc":"Returns an iterator over all instructions in the given addressSet. The iterator\n will go from the lowest address to the largest or from the largest to the\n lowest depending on the forward parameter.\n@param forward determines if the iterator goes from lowest address to highest\n or the other way around.","static":false,"name":"getInstructions","comment":"Returns an iterator over all instructions in the given addressSet. The iterator\n will go from the lowest address to the largest or from the largest to the\n lowest depending on the forward parameter.","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"set","comment":"","type_short":"AddressSetView"},{"type_long":"boolean","name":"forward","comment":"determines if the iterator goes from lowest address to highest\n or the other way around.","type_short":"boolean"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.InstructionIterator","comment":"","type_short":"InstructionIterator"}},{"javadoc":"Returns an iterator over all data in the program from the given\n start address to either the end address or the start address, depending if\n the iterator is forward or not.\n@param start the starting address for the iterator.\n@param forward if true the iterator returns all data from the given\n start address to the end of the program, otherwise it returns all data\n from the given start address to the start of the program.","static":false,"name":"getData","comment":"Returns an iterator over all data in the program from the given\n start address to either the end address or the start address, depending if\n the iterator is forward or not.","params":[{"type_long":"ghidra.program.model.address.Address","name":"start","comment":"the starting address for the iterator.","type_short":"Address"},{"type_long":"boolean","name":"forward","comment":"if true the iterator returns all data from the given\n start address to the end of the program, otherwise it returns all data\n from the given start address to the start of the program.","type_short":"boolean"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.DataIterator","comment":"","type_short":"DataIterator"}},{"javadoc":"Returns an iterator over all data in the given addressSet. The iterator\n will go from the lowest address to the largest or from the largest to the\n lowest depending on the forward parameter.\n@param forward determines if the iterator goes from lowest address to highest\n or the other way around.","static":false,"name":"getData","comment":"Returns an iterator over all data in the given addressSet. The iterator\n will go from the lowest address to the largest or from the largest to the\n lowest depending on the forward parameter.","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"addrSet","comment":"","type_short":"AddressSetView"},{"type_long":"boolean","name":"forward","comment":"determines if the iterator goes from lowest address to highest\n or the other way around.","type_short":"boolean"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.DataIterator","comment":"","type_short":"DataIterator"}},{"javadoc":"Returns an iterator over all defined data in the given addressSet. The iterator\n will go from the lowest address to the largest or from the largest to the\n lowest depending on the forward parameter.\n@param forward determines if the iterator goes from lowest address to highest\n or the other way around.","static":false,"name":"getDefinedData","comment":"Returns an iterator over all defined data in the given addressSet. The iterator\n will go from the lowest address to the largest or from the largest to the\n lowest depending on the forward parameter.","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"addrSet","comment":"","type_short":"AddressSetView"},{"type_long":"boolean","name":"forward","comment":"determines if the iterator goes from lowest address to highest\n or the other way around.","type_short":"boolean"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.DataIterator","comment":"","type_short":"DataIterator"}},{"javadoc":"Check if any instruction intersects the specified address range\n@param start start of range\n@param end end of range\n@return true if instruction intersected with range","static":false,"name":"checkContextWrite","comment":"Check if any instruction intersects the specified address range","params":[{"type_long":"ghidra.program.model.address.Address","name":"start","comment":"start of range","type_short":"Address"},{"type_long":"ghidra.program.model.address.Address","name":"end","comment":"end of range","type_short":"Address"}],"throws":[{"type_long":"ghidra.program.model.listing.ContextChangeException","comment":"","type_short":"ContextChangeException"}],"return":{"type_long":"void","comment":"true if instruction intersected with range","type_short":"void"}},{"javadoc":"Checks if all the addresses from start to end have undefined data.\n@param start the first address in the range to check.\n@param end the last address in the range to check.\n@return true if all the addresses in the range have undefined data.","static":false,"name":"isUndefined","comment":"Checks if all the addresses from start to end have undefined data.","params":[{"type_long":"ghidra.program.model.address.Address","name":"start","comment":"the first address in the range to check.","type_short":"Address"},{"type_long":"ghidra.program.model.address.Address","name":"end","comment":"the last address in the range to check.","type_short":"Address"}],"throws":[],"return":{"type_long":"boolean","comment":"true if all the addresses in the range have undefined data.","type_short":"boolean"}},{"javadoc":"Removes any data objects that have dataTypes matching the given dataType ids.\n@param dataTypeIDs the list of ids of dataTypes that have been deleted.\n@param monitor TaskMonitor used to monitor progress and keeps track if the\n user cancels the operation.","static":false,"name":"clearData","comment":"Removes any data objects that have dataTypes matching the given dataType ids.","params":[{"type_long":"long[]","name":"dataTypeIDs","comment":"the list of ids of dataTypes that have been deleted.","type_short":"long[]"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"TaskMonitor used to monitor progress and keeps track if the\n user cancels the operation.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns the reference manager being used by this code manager.\n@return ReferenceManager the reference manager being used by this code manager","static":false,"name":"getReferenceMgr","comment":"Returns the reference manager being used by this code manager.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.ReferenceManager","comment":"ReferenceManager the reference manager being used by this code manager","type_short":"ReferenceManager"}},{"javadoc":"Invalidates all cached database objects","static":false,"name":"invalidateCache","comment":"Invalidates all cached database objects","params":[{"type_long":"boolean","name":"all","comment":"","type_short":"boolean"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Invalidates the cache for the codeUnits.","static":false,"name":"invalidateCodeUnitCache","comment":"Invalidates the cache for the codeUnits.","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Notification that memory has changed, so clear the cache for the\n affected code units.\n@param addr start of change\n@param end end address of change","static":false,"name":"memoryChanged","comment":"Notification that memory has changed, so clear the cache for the\n affected code units.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"start of change","type_short":"Address"},{"type_long":"ghidra.program.model.address.Address","name":"end","comment":"end address of change","type_short":"Address"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Callback from ReferenceManager when a new fall-through reference is set.\n@param fromAddr fall-through from location\n@param newFallThroughRef new fallthrough reference or null if removed","static":false,"name":"fallThroughChanged","comment":"Callback from ReferenceManager when a new fall-through reference is set.","params":[{"type_long":"ghidra.program.model.address.Address","name":"fromAddr","comment":"fall-through from location","type_short":"Address"},{"type_long":"ghidra.program.model.symbol.Reference","name":"newFallThroughRef","comment":"new fallthrough reference or null if removed","type_short":"Reference"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Get the comment for the given type at the specified address.\n@param commentType either EOL_COMMENT, PRE_COMMENT,\n POST_COMMENT, PLATE_COMMENT, or REPEATABLE_COMMENT\n@param address the address of the comment.\n@return the comment string of the appropriate type or null if no comment of\n that type exists for this codeunit\n@throws IllegalArgumentException if type is not one of the\n types of comments supported","static":false,"name":"getComment","comment":"Get the comment for the given type at the specified address.","params":[{"type_long":"int","name":"commentType","comment":"either EOL_COMMENT, PRE_COMMENT,\n POST_COMMENT, PLATE_COMMENT, or REPEATABLE_COMMENT","type_short":"int"},{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address of the comment.","type_short":"Address"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"the comment string of the appropriate type or null if no comment of\n that type exists for this codeunit","type_short":"String"}},{"javadoc":"Set the comment for the given comment type at the specified address.\n@param address the address of the comment.\n@param commentType either EOL_COMMENT, PRE_COMMENT,\n POST_COMMENT, PLATE_COMMENT, or REPEATABLE_COMMENT\n@param comment comment to set at the address\n@throws IllegalArgumentException if type is not one of the\n types of comments supported","static":false,"name":"setComment","comment":"Set the comment for the given comment type at the specified address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address of the comment.","type_short":"Address"},{"type_long":"int","name":"commentType","comment":"either EOL_COMMENT, PRE_COMMENT,\n POST_COMMENT, PLATE_COMMENT, or REPEATABLE_COMMENT","type_short":"int"},{"type_long":"java.lang.String","name":"comment","comment":"comment to set at the address","type_short":"String"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Get the comment history for the comment type at the given address.\n@param addr address for the comment history\n@param commentType comment type\n@return zero length array if no history exists","static":false,"name":"getCommentHistory","comment":"Get the comment history for the comment type at the given address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"address for the comment history","type_short":"Address"},{"type_long":"int","name":"commentType","comment":"comment type","type_short":"int"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.CommentHistory[]","comment":"zero length array if no history exists","type_short":"ghidra.program.model.listing.CommentHistory[]"}},{"javadoc":"","static":false,"name":"replaceDataTypes","comment":"","params":[{"type_long":"long","name":"oldDataTypeID","comment":"","type_short":"long"},{"type_long":"long","name":"newDataTypeID","comment":"","type_short":"long"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Complete language transformation of all instructions.  All existing prototypes will\n be discarded and all instructions redisassembled following flow and adjusting context as needed.\n Instructions which fail to redisassemble will be marked - since only one byte will be skipped, such bad\n instruction disassembly may cause subsequent errors due to possible instruction shift.\n This method is only intended for use by the ProgramDB setLanguage method.\n@param lang new language\n@param bookmarkLimit maximum number of errors to bookmark\n@param monitor task monitor\n@throws IOException\n@throws CancelledException\n@throws LockException","static":false,"name":"reDisassembleAllInstructions","comment":"Complete language transformation of all instructions.  All existing prototypes will\n be discarded and all instructions redisassembled following flow and adjusting context as needed.\n Instructions which fail to redisassemble will be marked - since only one byte will be skipped, such bad\n instruction disassembly may cause subsequent errors due to possible instruction shift.\n This method is only intended for use by the ProgramDB setLanguage method.","params":[{"type_long":"int","name":"bookmarkLimit","comment":"maximum number of errors to bookmark","type_short":"int"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"task monitor","type_short":"TaskMonitor"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"},{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns a substring of s beginning at start and ending at either the end of the string or\n the first newLine at or after start.\n@param s the string to scan\n@param start the starting position for the scan\n@return A string that represents a line within s.","static":true,"name":"getLine","comment":"Returns a substring of s beginning at start and ending at either the end of the string or\n the first newLine at or after start.","params":[{"type_long":"java.lang.String","name":"s","comment":"the string to scan","type_short":"String"},{"type_long":"int","name":"start","comment":"the starting position for the scan","type_short":"int"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"A string that represents a line within s.","type_short":"String"}}],"name":"CodeManager","comment":"Class to manage database tables for data and instructions.","fields":[]}
