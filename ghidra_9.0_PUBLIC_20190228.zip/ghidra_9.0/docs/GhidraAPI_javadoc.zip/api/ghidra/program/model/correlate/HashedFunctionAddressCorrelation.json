{"implements":["ghidra.program.util.FunctionAddressCorrelation"],"javadoc":"Correlator to construct a 1-1 map between the Instructions of two similar Functions. Matching is performed\n via a greedy algorithm that looks for sequences (n-grams) of Instructions that are similar between the two Functions.\n Similarity of two sequences is determined by comparing hashes generated by the HashCalculator object.\n \n 1) Potential sequences and their hashes are generated for both functions (see HashStore).\n 2) Sequences are pulled from the HashStore based on the uniqueness of a potential match and on the size of the sequence.\n 3) If a unique match is found between sequences, it is extended in either direction as far as possible,\n    as constrained by HashCalculator and the containing basic-blocks.\n 4) The matching Instruction pairs are put in the final map and removed from further sequence lists\n    to allow other potential matches to be considered.\n 5) Sequences with no corresponding match are also removed from consideration.\n 6) Sequences are limited to a single basic-block, and the algorithm is basic-block aware.\n    Once a match establishes a correspondence between a pair of basic blocks, the algorithm uses\n    that information to further narrow in on and disambiguate matching sequences.\n 7) If a particular sequence has matches that are not unique, the algorithm tries to disambiguate the potential\n    matches by looking at parent\/child relationships of the containing basic-blocks. (see DisambiguateStrategy)\n 8) Multiple passes are attempted, each time the set of potential sequences is completely regenerated,\n    varying the range of sequence sizes for which a match is attempted and other hash parameters. This\n    allows matches discovered by earlier passes to disambiguate sequences in later passes.","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"Correlates addresses between the two specified functions.\n@param function1 the first function\n@param function2 the second function\n@param mon the task monitor that indicates progress and allows the user to cancel.\n@throws CancelledException if the user cancels\n@throws MemoryAccessException if either functions memory can't be accessed.","static":false,"name":"<init>","comment":"Correlates addresses between the two specified functions.","params":[{"type_long":"ghidra.program.model.listing.Function","name":"function1","comment":"the first function","type_short":"Function"},{"type_long":"ghidra.program.model.listing.Function","name":"function2","comment":"the second function","type_short":"Function"},{"type_long":"ghidra.util.task.TaskMonitor","name":"mon","comment":"the task monitor that indicates progress and allows the user to cancel.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if the user cancels","type_short":"CancelledException"},{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"if either functions memory can't be accessed.","type_short":"MemoryAccessException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"getFirstProgram","comment":"","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Program","comment":"","type_short":"Program"}},{"javadoc":"","static":false,"name":"getSecondProgram","comment":"","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Program","comment":"","type_short":"Program"}},{"javadoc":"","static":false,"name":"getAddressesInFirst","comment":"","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.address.AddressSetView","comment":"","type_short":"AddressSetView"}},{"javadoc":"","static":false,"name":"getAddressesInSecond","comment":"","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.address.AddressSetView","comment":"","type_short":"AddressSetView"}},{"javadoc":"Gets the total number of instructions that are in the first function.\n@return the first function's instruction count.","static":false,"name":"getTotalInstructionsInFirst","comment":"Gets the total number of instructions that are in the first function.","params":[],"throws":[],"return":{"type_long":"int","comment":"the first function's instruction count.","type_short":"int"}},{"javadoc":"Gets the total number of instructions that are in the second function.\n@return the second function's instruction count.","static":false,"name":"getTotalInstructionsInSecond","comment":"Gets the total number of instructions that are in the second function.","params":[],"throws":[],"return":{"type_long":"int","comment":"the second function's instruction count.","type_short":"int"}},{"javadoc":"Determines the number of instructions from the first function that match an instruction\n in the second function.\n@return the number of instructions in the first function that have matches.","static":false,"name":"numMatchedInstructionsInFirst","comment":"Determines the number of instructions from the first function that match an instruction\n in the second function.","params":[],"throws":[],"return":{"type_long":"int","comment":"the number of instructions in the first function that have matches.","type_short":"int"}},{"javadoc":"Determines the number of instructions from the second function that match an instruction\n in the first function.\n@return the number of instructions in the second function that have matches.","static":false,"name":"numMatchedInstructionsInSecond","comment":"Determines the number of instructions from the second function that match an instruction\n in the first function.","params":[],"throws":[],"return":{"type_long":"int","comment":"the number of instructions in the second function that have matches.","type_short":"int"}},{"javadoc":"Determines the number of instructions from the first function that do not match an \n instruction in the second function.\n@return the number of instructions in the first function without matches.","static":false,"name":"getUnmatchedInstructionsInFirst","comment":"Determines the number of instructions from the first function that do not match an \n instruction in the second function.","params":[],"throws":[],"return":{"type_long":"java.util.List<ghidra.program.model.listing.Instruction>","comment":"the number of instructions in the first function without matches.","type_short":"List"}},{"javadoc":"Determines the number of instructions from the second function that do not match an \n instruction in the first function.\n@return the number of instructions in the second function without matches.","static":false,"name":"getUnmatchedInstructionsInSecond","comment":"Determines the number of instructions from the second function that do not match an \n instruction in the first function.","params":[],"throws":[],"return":{"type_long":"java.util.List<ghidra.program.model.listing.Instruction>","comment":"the number of instructions in the second function without matches.","type_short":"List"}},{"javadoc":"Gets an iterator of the matching addresses from the first function to the second.\n@return the iterator","static":false,"name":"getFirstToSecondIterator","comment":"Gets an iterator of the matching addresses from the first function to the second.","params":[],"throws":[],"return":{"type_long":"java.util.Iterator<java.util.Map.Entry<ghidra.program.model.address.Address,ghidra.program.model.address.Address>>","comment":"the iterator","type_short":"Iterator"}},{"javadoc":"","static":false,"name":"getAddressInSecond","comment":"","params":[{"type_long":"ghidra.program.model.address.Address","name":"addressInFirst","comment":"","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"","type_short":"Address"}},{"javadoc":"","static":false,"name":"getAddressInFirst","comment":"","params":[{"type_long":"ghidra.program.model.address.Address","name":"addressInSecond","comment":"","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"","type_short":"Address"}},{"javadoc":"","static":false,"name":"getFirstFunction","comment":"","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Function","comment":"","type_short":"Function"}},{"javadoc":"","static":false,"name":"getSecondFunction","comment":"","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Function","comment":"","type_short":"Function"}}],"name":"HashedFunctionAddressCorrelation","comment":"Correlator to construct a 1-1 map between the Instructions of two similar Functions. Matching is performed\n via a greedy algorithm that looks for sequences (n-grams) of Instructions that are similar between the two Functions.\n Similarity of two sequences is determined by comparing hashes generated by the HashCalculator object.\n \n 1) Potential sequences and their hashes are generated for both functions (see HashStore).\n 2) Sequences are pulled from the HashStore based on the uniqueness of a potential match and on the size of the sequence.\n 3) If a unique match is found between sequences, it is extended in either direction as far as possible,\n    as constrained by HashCalculator and the containing basic-blocks.\n 4) The matching Instruction pairs are put in the final map and removed from further sequence lists\n    to allow other potential matches to be considered.\n 5) Sequences with no corresponding match are also removed from consideration.\n 6) Sequences are limited to a single basic-block, and the algorithm is basic-block aware.\n    Once a match establishes a correspondence between a pair of basic blocks, the algorithm uses\n    that information to further narrow in on and disambiguate matching sequences.\n 7) If a particular sequence has matches that are not unique, the algorithm tries to disambiguate the potential\n    matches by looking at parent\/child relationships of the containing basic-blocks. (see DisambiguateStrategy)\n 8) Multiple passes are attempted, each time the set of potential sequences is completely regenerated,\n    varying the range of sequence sizes for which a match is attempted and other hash parameters. This\n    allows matches discovered by earlier passes to disambiguate sequences in later passes.","fields":[]}
