{"implements":["ghidra.util.prop.PropertyVisitor"],"javadoc":"<CODE>ProgramMerge<\/CODE> is a class for merging the differences between two\n programs. The differences are merged from program2 into program1.\n <P>Program1 is the program being modified by the merge. Program2 is source\n for obtaining differences to apply to program1.\n <P>If name conflicts occur while merging, the item (for example, symbol) will\n be merged with a new name that consists of the original name followed by \"_conflict\"\n and a one up number.","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"<CODE>ProgramMerge<\/CODE> allows the merging of differences from program2\n into program1 (the result program).\n@param resultProgram The result program that will get modified by merge.\n@param originProgram The program (used as read only) for obtaining\n differences to merge.","static":false,"name":"<init>","comment":"ProgramMerge allows the merging of differences from program2\n into program1 (the result program).","params":[{"type_long":"ghidra.program.model.listing.Program","name":"resultProgram","comment":"The result program that will get modified by merge.","type_short":"Program"},{"type_long":"ghidra.program.model.listing.Program","name":"originProgram","comment":"The program (used as read only) for obtaining\n differences to merge.","type_short":"Program"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>ProgramMerge<\/CODE> allows the merging of differences from program2 (the origin program)\n into program1 (the result program).\n <br>If the address translator is not a \"one for one translator\" then certain methods within\n this class will throw an UnsupportedOperationException.\n The destination program from the address translator should be the result program into\n which changes are made.\n The source program from the translator is the origin program for obtaining the changes.\n@param addressTranslator converts addresses from the origin program into an\n equivalent address in the destination program.\n@see AddressTranslator","static":false,"name":"<init>","comment":"ProgramMerge allows the merging of differences from program2 (the origin program)\n into program1 (the result program).\n If the address translator is not a \"one for one translator\" then certain methods within\n this class will throw an UnsupportedOperationException.\n The destination program from the address translator should be the result program into\n which changes are made.\n The source program from the translator is the origin program for obtaining the changes.","params":[{"type_long":"ghidra.program.util.AddressTranslator","name":"originToResultTranslator","comment":"","type_short":"AddressTranslator"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Gets the result program. Merge changes are applied to this program.\n@return the program being changed by the merge.","static":false,"name":"getResultProgram","comment":"Gets the result program. Merge changes are applied to this program.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Program","comment":"the program being changed by the merge.","type_short":"Program"}},{"javadoc":"Gets the origin program. This program is used for obtaining things to merge into program1.\n@return the program we are obtaining the changes from which we will merge.","static":false,"name":"getOriginProgram","comment":"Gets the origin program. This program is used for obtaining things to merge into program1.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Program","comment":"the program we are obtaining the changes from which we will merge.","type_short":"Program"}},{"javadoc":"Determines if this ProgramMerge currently has an error message.\n@return true if there is an error message.","static":false,"name":"hasErrorMessage","comment":"Determines if this ProgramMerge currently has an error message.","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if there is an error message.","type_short":"boolean"}},{"javadoc":"Determines if this ProgramMerge currently has an informational message.\n@return true if there is an information message.","static":false,"name":"hasInfoMessage","comment":"Determines if this ProgramMerge currently has an informational message.","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if there is an information message.","type_short":"boolean"}},{"javadoc":"Get the error messages that resulted from the last call to a merge or\n replace method. These are errors that prevented something from being merged.\n <br>Important: Call clearErrorMessage() to clear the current error message after this returns it.\n@return the error message string or an empty string if there were no problems with the merge.","static":false,"name":"getErrorMessage","comment":"Get the error messages that resulted from the last call to a merge or\n replace method. These are errors that prevented something from being merged.\n Important: Call clearErrorMessage() to clear the current error message after this returns it.","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"the error message string or an empty string if there were no problems with the merge.","type_short":"String"}},{"javadoc":"Get the information messages that resulted from the last call to a merge or\n replace method. These messages are non-critical changes that were\n necessary during the merge. For example giving a symbol a name with a conflict\n extension because another symbol with that name existed elsewhere in the\n program already.\n <br>Important: Call clearInfoMessage() to clear the current info message after this returns it.\n@return the information message string or an empty string if there were no informational\n messages for the merge.","static":false,"name":"getInfoMessage","comment":"Get the information messages that resulted from the last call to a merge or\n replace method. These messages are non-critical changes that were\n necessary during the merge. For example giving a symbol a name with a conflict\n extension because another symbol with that name existed elsewhere in the\n program already.\n Important: Call clearInfoMessage() to clear the current info message after this returns it.","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"the information message string or an empty string if there were no informational\n messages for the merge.","type_short":"String"}},{"javadoc":"This method clears the current error message.","static":false,"name":"clearErrorMessage","comment":"This method clears the current error message.","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"This method clears the current informational message.","static":false,"name":"clearInfoMessage","comment":"This method clears the current informational message.","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>mergeBytes<\/CODE> merges byte differences within the specified\n  address set.\n <br>Note: Any instructions at the equivalent byte addresses in the result program will get cleared and\n re-created resulting in the existing references being dropped.\n@param originAddressSet the addresses to be merged.\n The addresses in this set are derived from the origin program.\n@param overwriteInstructions if true affected instructions will be cleared and\n re-disassmebled after bytes are modified\n@param monitor the task monitor for notifying the user of this merge's\n progress.\n@throws MemoryAccessException if bytes can't be merged.\n@throws CancelledException if user cancels via the monitor.\n@throws UnsupportedOperationException if the ProgramMerge translator is not a\n \"one for one translator\".","static":false,"name":"mergeBytes","comment":"mergeBytes merges byte differences within the specified\n  address set.\n Note: Any instructions at the equivalent byte addresses in the result program will get cleared and\n re-created resulting in the existing references being dropped.","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"originAddressSet","comment":"the addresses to be merged.\n The addresses in this set are derived from the origin program.","type_short":"AddressSetView"},{"type_long":"boolean","name":"overwriteInstructions","comment":"if true affected instructions will be cleared and\n re-disassmebled after bytes are modified","type_short":"boolean"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's\n progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"if bytes can't be merged.","type_short":"MemoryAccessException"},{"type_long":"ghidra.util.exception.CancelledException","comment":"if user cancels via the monitor.","type_short":"CancelledException"},{"type_long":"java.lang.UnsupportedOperationException","comment":"if the ProgramMerge translator is not a\n \"one for one translator\".","type_short":"UnsupportedOperationException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>mergeCodeUnits<\/CODE> merges all instructions &\/or data\n (as indicated) in the specified address set from the origin program.\n It merges them into the result program. When merging\n instructions, the bytes are also replaced if they differ.\n This assumes originToResultTranslator maps address spaces and does\n not do fine-grained mapping of addresses.\n@param addrSet the addresses to be merged.\n The addresses in this set should be derived from the origin program.\n@param byteDiffs address set indicating addresses where the bytes differ\n between the result program and the origin program.\n The addresses in this set should be derived from the origin program.\n@param mergeDataBytes true indicates bytes that differ should be copied when merging Data.\n false means don't copy any bytes for Data.\n@param monitor the task monitor for notifying the user of this merge's\n progress.\n@throws MemoryAccessException if bytes can't be copied.\n@throws CancelledException if user cancels via the monitor.\n@throws UnsupportedOperationException if the ProgramMerge translator is not a\n \"one for one translator\".","static":false,"name":"mergeCodeUnits","comment":"mergeCodeUnits merges all instructions \/or data\n (as indicated) in the specified address set from the origin program.\n It merges them into the result program. When merging\n instructions, the bytes are also replaced if they differ.\n This assumes originToResultTranslator maps address spaces and does\n not do fine-grained mapping of addresses.","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"originAddressSet","comment":"","type_short":"AddressSetView"},{"type_long":"ghidra.program.model.address.AddressSetView","name":"byteDiffs","comment":"address set indicating addresses where the bytes differ\n between the result program and the origin program.\n The addresses in this set should be derived from the origin program.","type_short":"AddressSetView"},{"type_long":"boolean","name":"mergeDataBytes","comment":"true indicates bytes that differ should be copied when merging Data.\n false means don't copy any bytes for Data.","type_short":"boolean"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's\n progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"if bytes can't be copied.","type_short":"MemoryAccessException"},{"type_long":"ghidra.util.exception.CancelledException","comment":"if user cancels via the monitor.","type_short":"CancelledException"},{"type_long":"java.lang.UnsupportedOperationException","comment":"if the ProgramMerge translator is not a\n \"one for one translator\".","type_short":"UnsupportedOperationException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>mergeEquates<\/CODE> merges the equate differences in the specified\n address set.\n@param originAddressSet the addresses to be merged.\n The addresses in this set should be derived from the origin program.\n@param monitor the task monitor for notifying the user of this merge's\n progress.\n@throws CancelledException if user cancels via the monitor.\n@throws UnsupportedOperationException if the ProgramMerge translators are not\n \"one for one translators\".","static":false,"name":"mergeEquates","comment":"mergeEquates merges the equate differences in the specified\n address set.","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"originAddressSet","comment":"the addresses to be merged.\n The addresses in this set should be derived from the origin program.","type_short":"AddressSetView"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's\n progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if user cancels via the monitor.","type_short":"CancelledException"},{"type_long":"java.lang.UnsupportedOperationException","comment":"if the ProgramMerge translators are not\n \"one for one translators\".","type_short":"UnsupportedOperationException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>mergeEquate<\/CODE> replaces the current equates in program1 with those in program2.\n@param originAddress the address where the equates should be merged.\n This address should be derived from the origin program.\n@param opIndex the operand index where the equates should be merged.\n@param value the scalar value where the equate is used.","static":false,"name":"mergeEquate","comment":"mergeEquate replaces the current equates in program1 with those in program2.","params":[{"type_long":"ghidra.program.model.address.Address","name":"originAddress","comment":"the address where the equates should be merged.\n This address should be derived from the origin program.","type_short":"Address"},{"type_long":"int","name":"opIndex","comment":"the operand index where the equates should be merged.","type_short":"int"},{"type_long":"long","name":"value","comment":"the scalar value where the equate is used.","type_short":"long"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>replaceReferences<\/CODE> replaces all references in\n program1 for the specified address set with those in program2.\n If an equivalent reference already exists then it is updated to match the\n new reference.\n <br> Note: All reference types (memory, stack, external) get replaced\n where possible. i.e. If a function or variable doesn't exist for a\n variable reference then it will not be able to replace the reference.\n@param originAddressSet the addresses to be merged.\n The addresses in this set should be derived from the origin program.\n@param monitor the task monitor for notifying the user of this merge's\n progress.\n@throws CancelledException if the user cancels the replace via the monitor.\n@throws UnsupportedOperationException if the ProgramMerge translators are not\n \"one for one translators\".","static":false,"name":"replaceReferences","comment":"replaceReferences replaces all references in\n program1 for the specified address set with those in program2.\n If an equivalent reference already exists then it is updated to match the\n new reference.\n  Note: All reference types (memory, stack, external) get replaced\n where possible. i.e. If a function or variable doesn't exist for a\n variable reference then it will not be able to replace the reference.","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"originAddressSet","comment":"the addresses to be merged.\n The addresses in this set should be derived from the origin program.","type_short":"AddressSetView"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's\n progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if the user cancels the replace via the monitor.","type_short":"CancelledException"},{"type_long":"java.lang.UnsupportedOperationException","comment":"if the ProgramMerge translators are not\n \"one for one translators\".","type_short":"UnsupportedOperationException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>replaceReferences<\/CODE> replaces all references in\n program1 for the specified address set with the references from program2.\n If an equivalent reference already exists then it is updated to match the\n new reference.\n <br> Note: All reference types (memory, stack, external) get replaced\n where possible. i.e. If a function or variable doesn't exist for a\n variable reference then it will not be able to replace the reference.\n@param originAddressSet the addresses to be merged.\n The addresses in this set should be derived from the origin program.\n@param onlyKeepDefaults true indicates to replace all references with only\n the default references from the origin program.\n@param monitor the task monitor for notifying the user of this merge's\n progress.\n@throws CancelledException if the user cancels the replace via the monitor.\n@throws UnsupportedOperationException if the ProgramMerge translators are not\n \"one for one translators\".","static":false,"name":"replaceReferences","comment":"replaceReferences replaces all references in\n program1 for the specified address set with the references from program2.\n If an equivalent reference already exists then it is updated to match the\n new reference.\n  Note: All reference types (memory, stack, external) get replaced\n where possible. i.e. If a function or variable doesn't exist for a\n variable reference then it will not be able to replace the reference.","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"originAddressSet","comment":"the addresses to be merged.\n The addresses in this set should be derived from the origin program.","type_short":"AddressSetView"},{"type_long":"boolean","name":"onlyKeepDefaults","comment":"true indicates to replace all references with only\n the default references from the origin program.","type_short":"boolean"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's\n progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if the user cancels the replace via the monitor.","type_short":"CancelledException"},{"type_long":"java.lang.UnsupportedOperationException","comment":"if the ProgramMerge translators are not\n \"one for one translators\".","type_short":"UnsupportedOperationException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>mergeReferences<\/CODE> merges the references in\n program1 for the specified address set with the references from program2.\n If an equivalent reference already exists then it is updated to match the\n new reference if possible. A merge of references prevents the loss of any\n non-default references already in the result program.\n <br> Important: Fallthrough references will not be merged by this method.\n Fallthroughs are handled by merging code units.\n <br> Note: All reference types (memory, stack, external) get replaced\n where possible. i.e. If a function or variable doesn't exist for a\n variable reference then it will not be able to replace the reference.\n@param originAddressSet the addresses to be merged.\n The addresses in this set should be derived from the origin program.\n@param onlyKeepDefaults true indicates to merge only the default references\n from the origin program into the result program. Non-default references will not be merged.\n false indicates merge all references except fallthroughs.\n@param monitor the task monitor for notifying the user of this merge's\n progress.\n@throws CancelledException if the user cancels the replace via the monitor.\n@throws UnsupportedOperationException if the ProgramMerge translators are not\n \"one for one translators\".","static":false,"name":"mergeReferences","comment":"mergeReferences merges the references in\n program1 for the specified address set with the references from program2.\n If an equivalent reference already exists then it is updated to match the\n new reference if possible. A merge of references prevents the loss of any\n non-default references already in the result program.\n  Important: Fallthrough references will not be merged by this method.\n Fallthroughs are handled by merging code units.\n  Note: All reference types (memory, stack, external) get replaced\n where possible. i.e. If a function or variable doesn't exist for a\n variable reference then it will not be able to replace the reference.","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"originAddressSet","comment":"the addresses to be merged.\n The addresses in this set should be derived from the origin program.","type_short":"AddressSetView"},{"type_long":"boolean","name":"onlyKeepDefaults","comment":"true indicates to merge only the default references\n from the origin program into the result program. Non-default references will not be merged.\n false indicates merge all references except fallthroughs.","type_short":"boolean"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's\n progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if the user cancels the replace via the monitor.","type_short":"CancelledException"},{"type_long":"java.lang.UnsupportedOperationException","comment":"if the ProgramMerge translators are not\n \"one for one translators\".","type_short":"UnsupportedOperationException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>replaceReferences<\/CODE> replaces all references in\n program1 for the specified address and operand index with those in program2.\n If an equivalent reference already exists then it is updated to match the\n new reference.\n <br> Note: All reference types (memory, stack, external) get replaced\n where possible. i.e. If a function or variable doesn't exist for a\n variable reference then it will not be able to replace the reference.\n@param originAddress the \"from\" address where references are to be replaced\n@param operandIndex the operand of the code unit at the address where\n references are to be replaced.","static":false,"name":"replaceReferences","comment":"replaceReferences replaces all references in\n program1 for the specified address and operand index with those in program2.\n If an equivalent reference already exists then it is updated to match the\n new reference.\n  Note: All reference types (memory, stack, external) get replaced\n where possible. i.e. If a function or variable doesn't exist for a\n variable reference then it will not be able to replace the reference.","params":[{"type_long":"ghidra.program.model.address.Address","name":"originAddress","comment":"the \"from\" address where references are to be replaced","type_short":"Address"},{"type_long":"int","name":"operandIndex","comment":"the operand of the code unit at the address where\n references are to be replaced.","type_short":"int"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Replaces the reference in program1 with the reference from the origin program.\n@param resultRef the program1 reference to be replaced.\n@param originRef the program2 reference used to replace what's in program1.\n@return the resulting reference in program1. null if reference is removed\n by the replace.","static":false,"name":"replaceReference","comment":"Replaces the reference in program1 with the reference from the origin program.","params":[{"type_long":"ghidra.program.model.symbol.Reference","name":"resultRef","comment":"the program1 reference to be replaced.","type_short":"Reference"},{"type_long":"ghidra.program.model.symbol.Reference","name":"originRef","comment":"the program2 reference used to replace what's in program1.","type_short":"Reference"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Reference","comment":"the resulting reference in program1. null if reference is removed\n by the replace.","type_short":"Reference"}},{"javadoc":"Replaces the reference in program1 with the reference from the origin program.\n@param resultRef the program1 reference to be replaced.\n@param originRef the program2 reference used to replace what's in program1.\n@param toSymbolID ID of the symbol in program1 the resulting reference is to.\n@return the resulting reference in program1. null if reference is removed\n by the replace.","static":false,"name":"replaceReference","comment":"Replaces the reference in program1 with the reference from the origin program.","params":[{"type_long":"ghidra.program.model.symbol.Reference","name":"resultRef","comment":"the program1 reference to be replaced.","type_short":"Reference"},{"type_long":"ghidra.program.model.symbol.Reference","name":"originRef","comment":"the program2 reference used to replace what's in program1.","type_short":"Reference"},{"type_long":"long","name":"toSymbolID","comment":"ID of the symbol in program1 the resulting reference is to.","type_short":"long"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Reference","comment":"the resulting reference in program1. null if reference is removed\n by the replace.","type_short":"Reference"}},{"javadoc":"<CODE>addReference<\/CODE> creates a reference in program1 that is equivalent\n to the one specified as a parameter. If a symbol ID is specified, the\n reference will refer to the symbol in program1 with that ID. If the reference\n is an external reference, then the external location associated with it can be replaced\n also by setting the replace external location flag.\n@param originRef the reference equivalent to the one to be created.\n@param toSymbolID ID of the symbol to referred to. null indicates don't\n refer directly to a symbol.\n@param replaceExtLoc the replace external location flag. true indicates to replace the\n external location, if applicable, with the one defined for the reference passed to this method.\n@return the reference that was created. null if none created.","static":false,"name":"addReference","comment":"addReference creates a reference in program1 that is equivalent\n to the one specified as a parameter. If a symbol ID is specified, the\n reference will refer to the symbol in program1 with that ID. If the reference\n is an external reference, then the external location associated with it can be replaced\n also by setting the replace external location flag.","params":[{"type_long":"ghidra.program.model.symbol.Reference","name":"originRef","comment":"the reference equivalent to the one to be created.","type_short":"Reference"},{"type_long":"long","name":"toSymbolID","comment":"ID of the symbol to referred to. null indicates don't\n refer directly to a symbol.","type_short":"long"},{"type_long":"boolean","name":"replaceExtLoc","comment":"the replace external location flag. true indicates to replace the\n external location, if applicable, with the one defined for the reference passed to this method.","type_short":"boolean"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Reference","comment":"the reference that was created. null if none created.","type_short":"Reference"}},{"javadoc":"<CODE>replaceFallThroughs<\/CODE> replaces all fallthroughs in\n program1 for the specified address set with those in program2 where they differ.\n@param originAddressSet the addresses to be merged.\n The addresses in this set should be derived from the origin program.\n@param monitor the task monitor for notifying the user of this merge's\n progress.\n@throws CancelledException if the user cancels the replace via the monitor.","static":false,"name":"replaceFallThroughs","comment":"replaceFallThroughs replaces all fallthroughs in\n program1 for the specified address set with those in program2 where they differ.","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"originAddressSet","comment":"the addresses to be merged.\n The addresses in this set should be derived from the origin program.","type_short":"AddressSetView"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's\n progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if the user cancels the replace via the monitor.","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>mergeComment<\/CODE> merges\/replaces comments of the indicated\n type wherever they occur in the specified address set.\n@param originAddressSet the addresses where comments should be merged\/replaced.\n The addresses in this set should be from the origin program.\n@param type ProgramMergeFilter comment type.\n The comment type can be PLATE, PRE, EOL, REPEATABLE, POST.\n@param both true means merge both program1 and program2 comments.\n false means replace the program1 comment with the program2 comment.\n@param monitor the task monitor for notifying the user of this merge's progress.\n@throws CancelledException if user cancels via the monitor.","static":false,"name":"mergeComment","comment":"mergeComment merges\/replaces comments of the indicated\n type wherever they occur in the specified address set.","params":[{"type_long":"ghidra.program.model.address.AddressSet","name":"originAddressSet","comment":"the addresses where comments should be merged\/replaced.\n The addresses in this set should be from the origin program.","type_short":"AddressSet"},{"type_long":"int","name":"type","comment":"ProgramMergeFilter comment type.\n The comment type can be PLATE, PRE, EOL, REPEATABLE, POST.","type_short":"int"},{"type_long":"boolean","name":"both","comment":"true means merge both program1 and program2 comments.\n false means replace the program1 comment with the program2 comment.","type_short":"boolean"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if user cancels via the monitor.","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>mergeCommentType<\/CODE> merges\/replaces comments of the indicated\n type wherever they occur in the specified address set.\n It merges them from program2 into program1.\n This merges eol, pre, post, repeatable, and plate comments.\n@param originAddressSet the addresses to be merged.\n The addresses in this set should be derived from the origin program.\n@param type the comment type. PLATE, PRE, EOL, REPEATABLE, POST\n@param setting how to merge. IGNORE, REPLACE, MERGE\n@param monitor the task monitor for notifying the user of this merge's progress.\n@throws CancelledException if user cancels via the monitor.","static":false,"name":"mergeCommentType","comment":"mergeCommentType merges\/replaces comments of the indicated\n type wherever they occur in the specified address set.\n It merges them from program2 into program1.\n This merges eol, pre, post, repeatable, and plate comments.","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"originAddressSet","comment":"the addresses to be merged.\n The addresses in this set should be derived from the origin program.","type_short":"AddressSetView"},{"type_long":"int","name":"type","comment":"the comment type. PLATE, PRE, EOL, REPEATABLE, POST","type_short":"int"},{"type_long":"int","name":"setting","comment":"how to merge. IGNORE, REPLACE, MERGE","type_short":"int"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if user cancels via the monitor.","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>mergeComments<\/CODE> merges the comment of the indicated\n type in program1 with the comment in program2 at the specified address.\n@param commentType comment type to merge (from CodeUnit class).\n <br>EOL_COMMENT, PRE_COMMENT, POST_COMMENT, REPEATABLE_COMMENT, OR PLATE_COMMENT.\n@param addr the address\n This address should be derived from the origin program.","static":false,"name":"mergeComments","comment":"mergeComments merges the comment of the indicated\n type in program1 with the comment in program2 at the specified address.","params":[{"type_long":"int","name":"commentType","comment":"comment type to merge (from CodeUnit class).\n EOL_COMMENT, PRE_COMMENT, POST_COMMENT, REPEATABLE_COMMENT, OR PLATE_COMMENT.","type_short":"int"},{"type_long":"ghidra.program.model.address.Address","name":"originAddress","comment":"","type_short":"Address"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>replaceComment<\/CODE> replaces the comment of the indicated\n type in program1 with the comment in program2 at the specified address.\n@param commentType comment type to replace (from CodeUnit class).\n <br>EOL_COMMENT, PRE_COMMENT, POST_COMMENT, REPEATABLE_COMMENT, OR PLATE_COMMENT.\n@param addr the address\n This address should be derived from the origin program.","static":false,"name":"replaceComment","comment":"replaceComment replaces the comment of the indicated\n type in program1 with the comment in program2 at the specified address.","params":[{"type_long":"int","name":"commentType","comment":"comment type to replace (from CodeUnit class).\n EOL_COMMENT, PRE_COMMENT, POST_COMMENT, REPEATABLE_COMMENT, OR PLATE_COMMENT.","type_short":"int"},{"type_long":"ghidra.program.model.address.Address","name":"originAddress","comment":"","type_short":"Address"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Merges\/replaces tags of program2 into program1. When merging, tags that are in\n conflict are replaced according to the user setting (ignore, replace, merge).\n@param originAddressSet the addresses to be merged.\n@param setting how to merge. IGNORE, REPLACE, MERGE\n@param discardTags tags to keep out of the final result\n@param keepTags tags to add to the final result\n@param monitor the task monitor for notifying the user of this merge's progress.\n@throws CancelledException if user cancels via the monitor.","static":false,"name":"applyFunctionTagChanges","comment":"Merges\/replaces tags of program2 into program1. When merging, tags that are in\n conflict are replaced according to the user setting (ignore, replace, merge).","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"originAddressSet","comment":"the addresses to be merged.","type_short":"AddressSetView"},{"type_long":"int","name":"setting","comment":"how to merge. IGNORE, REPLACE, MERGE","type_short":"int"},{"type_long":"java.util.Set<ghidra.program.model.listing.FunctionTag>","name":"discardTags","comment":"tags to keep out of the final result","type_short":"Set"},{"type_long":"java.util.Set<ghidra.program.model.listing.FunctionTag>","name":"keepTags","comment":"tags to add to the final result","type_short":"Set"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if user cancels via the monitor.","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>mergeLabels<\/CODE> merges all symbols and aliases\n in the specified address set from the second program.\n It merges them into the merge program.\n@param originAddressSet the addresses to be merged.\n The addresses in this address set should be derived from program1.\n@param setting the current label setting.\n@param monitor the task monitor for notifying the user of this merge's\n progress.\n@throws CancelledException if user cancels via the monitor.","static":false,"name":"mergeLabels","comment":"mergeLabels merges all symbols and aliases\n in the specified address set from the second program.\n It merges them into the merge program.","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"originAddressSet","comment":"the addresses to be merged.\n The addresses in this address set should be derived from program1.","type_short":"AddressSetView"},{"type_long":"int","name":"setting","comment":"the current label setting.","type_short":"int"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's\n progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if user cancels via the monitor.","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>replaceLabels<\/CODE> replaces all symbols and aliases\n in the specified address set from the second program.\n@param originAddressSet the addresses to be replaced\n The addresses in this address set should be derived from program1.\n@param replaceFunction true indicates the function symbol should be replaced\n@param monitor the task monitor for notifying the user of this merge's progress\n@throws CancelledException if user cancels via the monitor.","static":false,"name":"replaceLabels","comment":"replaceLabels replaces all symbols and aliases\n in the specified address set from the second program.","params":[{"type_long":"ghidra.program.model.address.AddressSet","name":"originAddressSet","comment":"the addresses to be replaced\n The addresses in this address set should be derived from program1.","type_short":"AddressSet"},{"type_long":"boolean","name":"replaceFunction","comment":"true indicates the function symbol should be replaced","type_short":"boolean"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's progress","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if user cancels via the monitor.","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>replaceFunctionNames<\/CODE> merges function name and namespace differences\n within the specified address set.\n@param originAddressSet the addresses to be merged.\n The addresses in this set should be derived from program1.\n@param monitor the task monitor for notifying the user of this merge's\n progress.\n@throws CancelledException if user cancels via the monitor.","static":false,"name":"replaceFunctionNames","comment":"replaceFunctionNames merges function name and namespace differences\n within the specified address set.","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"originAddressSet","comment":"the addresses to be merged.\n The addresses in this set should be derived from program1.","type_short":"AddressSetView"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's\n progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if user cancels via the monitor.","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>mergeFunctions<\/CODE> merges function differences within the specified\n  address set.\n@param addrSet the addresses to be merged.\n The addresses in this set should be derived from program1.\n@param monitor the task monitor for notifying the user of this merge's\n progress.\n@throws CancelledException if user cancels via the monitor.","static":false,"name":"mergeFunctions","comment":"mergeFunctions merges function differences within the specified\n  address set.","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"addrSet","comment":"the addresses to be merged.\n The addresses in this set should be derived from program1.","type_short":"AddressSetView"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's\n progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if user cancels via the monitor.","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>mergeFunction<\/CODE> completely replaces any function at the\n indicated address in program1 with the function, if any, in program2.\n@param entry the entry point address of the function to be merged.\n This address should be derived from program1.\n@param monitor the task monitor for notifying the user of this merge's progress.\n@throws CancelledException if user cancels via the monitor.","static":false,"name":"mergeFunction","comment":"mergeFunction completely replaces any function at the\n indicated address in program1 with the function, if any, in program2.","params":[{"type_long":"ghidra.program.model.address.Address","name":"entry","comment":"the entry point address of the function to be merged.\n This address should be derived from program1.","type_short":"Address"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if user cancels via the monitor.","type_short":"CancelledException"}],"return":{"type_long":"ghidra.program.model.listing.Function","comment":"","type_short":"Function"}},{"javadoc":"<CODE>mergeFunctionReturn<\/CODE> replaces the return type\/storage of the\n function in program1 with the return type\/storage of the function in program2\n at the specified entry point address.\n@param entry the entry point address of the function.\n This address should be derived from the origin program.\n@param monitor the task monitor for notifying the user of this merge's progress.","static":false,"name":"mergeFunctionReturn","comment":"mergeFunctionReturn replaces the return type\/storage of the\n function in program1 with the return type\/storage of the function in program2\n at the specified entry point address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"entry2","comment":"","type_short":"Address"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>mergeFunctionName<\/CODE> replaces the name of the\n function in program1 with the name of the function in program2\n at the specified entry point address.\n@param entry the entry point address of the function.\n This address should be derived from the origin program.\n@param monitor the task monitor for notifying the user of this merge's progress.\n@throws InvalidInputException\n@throws DuplicateNameException","static":false,"name":"mergeFunctionName","comment":"mergeFunctionName replaces the name of the\n function in program1 with the name of the function in program2\n at the specified entry point address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"entry2","comment":"","type_short":"Address"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's progress.","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>replaceFunctionSignatureSource<\/CODE> changes the result function's signature source\n to match the origin program's signature source.\n@param originEntryPoint the entry point address of the function.\n This address should be derived from the origin program.\n@param monitor the task monitor for notifying the user of this merge's progress.","static":false,"name":"replaceFunctionSignatureSource","comment":"replaceFunctionSignatureSource changes the result function's signature source\n to match the origin program's signature source.","params":[{"type_long":"ghidra.program.model.address.Address","name":"originEntryPoint","comment":"the entry point address of the function.\n This address should be derived from the origin program.","type_short":"Address"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's progress.","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>mergeFunctionReturnAddressOffset<\/CODE> replaces the return address offset of the\n function in program1 with the return address offset of the function in program2\n at the specified entry point address.\n@param entry2 the entry point address of the function.\n This address should be derived from the origin program.\n@param monitor the task monitor for notifying the user of this merge's progress.","static":false,"name":"mergeFunctionReturnAddressOffset","comment":"mergeFunctionReturnAddressOffset replaces the return address offset of the\n function in program1 with the return address offset of the function in program2\n at the specified entry point address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"entry2","comment":"the entry point address of the function.\n This address should be derived from the origin program.","type_short":"Address"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's progress.","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>mergeFunctionLocalSize<\/CODE> replaces the local size of the\n function in program1 with the local size of the function in program2\n at the specified entry point address.\n@param entry2 the entry point address of the function.\n This address should be derived from the origin program.\n@param monitor the task monitor for notifying the user of this merge's progress.","static":false,"name":"mergeFunctionLocalSize","comment":"mergeFunctionLocalSize replaces the local size of the\n function in program1 with the local size of the function in program2\n at the specified entry point address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"entry2","comment":"the entry point address of the function.\n This address should be derived from the origin program.","type_short":"Address"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's progress.","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>mergeFunctionStackPurgeSize<\/CODE> replaces the stack purge size of the\n function in program1 with the stack purge size of the function in program2\n at the specified entry point address.\n@param entry2 the entry point address of the function.\n This address should be derived from the origin program.\n@param monitor the task monitor for notifying the user of this merge's progress.","static":false,"name":"mergeFunctionStackPurgeSize","comment":"mergeFunctionStackPurgeSize replaces the stack purge size of the\n function in program1 with the stack purge size of the function in program2\n at the specified entry point address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"entry2","comment":"the entry point address of the function.\n This address should be derived from the origin program.","type_short":"Address"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's progress.","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>replaceFunctionVarArgs<\/CODE> changes whether the function has VarArgs\n in program1 if it doesn't match the use of VarArgs in the function in program2\n at the specified entry point address.\n@param entry2 the entry point address of the function.\n This address should be derived from program1.\n@param monitor the task monitor for notifying the user of this merge's progress.","static":false,"name":"replaceFunctionVarArgs","comment":"replaceFunctionVarArgs changes whether the function has VarArgs\n in program1 if it doesn't match the use of VarArgs in the function in program2\n at the specified entry point address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"entry2","comment":"the entry point address of the function.\n This address should be derived from program1.","type_short":"Address"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's progress.","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>replaceFunctionCallingConvention<\/CODE> changes the function calling convention\n in program1 if it doesn't match the function calling convention in program2\n at the specified entry point address.\n@param originEntryPoint the entry point address of the function.\n This address should be derived from the origin program.\n@param monitor the task monitor for notifying the user of this merge's progress.","static":false,"name":"replaceFunctionCallingConvention","comment":"replaceFunctionCallingConvention changes the function calling convention\n in program1 if it doesn't match the function calling convention in program2\n at the specified entry point address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"originEntryPoint","comment":"the entry point address of the function.\n This address should be derived from the origin program.","type_short":"Address"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's progress.","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>replaceFunctionInlineFlag<\/CODE> changes whether the function is inline\n in program1 if it doesn't match whether the function is inline in program2\n at the specified entry point address.\n@param originEntryPoint the entry point address of the function.\n This address should be derived from the origin program.\n@param monitor the task monitor for notifying the user of this merge's progress.","static":false,"name":"replaceFunctionInlineFlag","comment":"replaceFunctionInlineFlag changes whether the function is inline\n in program1 if it doesn't match whether the function is inline in program2\n at the specified entry point address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"originEntryPoint","comment":"the entry point address of the function.\n This address should be derived from the origin program.","type_short":"Address"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's progress.","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>replaceFunctionNoReturnFlag<\/CODE> changes whether the flag is set indicating\n the function does not return\n in program1 if it doesn't match the \"does not return\" flag in the function in program2\n at the specified entry point address.\n@param originEntryPoint the entry point address of the function.\n This address should be derived from the origin program.\n@param monitor the task monitor for notifying the user of this merge's progress.","static":false,"name":"replaceFunctionNoReturnFlag","comment":"replaceFunctionNoReturnFlag changes whether the flag is set indicating\n the function does not return\n in program1 if it doesn't match the \"does not return\" flag in the function in program2\n at the specified entry point address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"originEntryPoint","comment":"the entry point address of the function.\n This address should be derived from the origin program.","type_short":"Address"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's progress.","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>replaceFunctionCustomStorageFlag<\/CODE> changes whether the flag is set indicating\n the function does not return\n in program1 if it doesn't match the \"custom storage\" flag in the function in program2\n at the specified entry point address.\n@param originEntryPoint the entry point address of the function.\n This address should be derived from the origin program.\n@param monitor the task monitor for notifying the user of this merge's progress.","static":false,"name":"replaceFunctionCustomStorageFlag","comment":"replaceFunctionCustomStorageFlag changes whether the flag is set indicating\n the function does not return\n in program1 if it doesn't match the \"custom storage\" flag in the function in program2\n at the specified entry point address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"originEntryPoint","comment":"the entry point address of the function.\n This address should be derived from the origin program.","type_short":"Address"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's progress.","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>replaceFunctionParameters<\/CODE> replaces the parameters of the\n function in program1 with the parameters of the function in program2\n at the specified entry point address.  It also replaces the return\n type\/storage as well as custom storage use.\n@param originEntryPoint the entry point address of the function.\n This address should be derived from the origin program.","static":false,"name":"replaceFunctionParameters","comment":"replaceFunctionParameters replaces the parameters of the\n function in program1 with the parameters of the function in program2\n at the specified entry point address.  It also replaces the return\n type\/storage as well as custom storage use.","params":[{"type_long":"ghidra.program.model.address.Address","name":"originEntryPoint","comment":"the entry point address of the function.\n This address should be derived from the origin program.","type_short":"Address"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>replaceFunctionParameters<\/CODE> replaces the parameters of the\n function in program1 with the parameters of the function in program2\n at the specified entry point address.  It also replaces the return\n type\/storage as well as custom storage use.\n@param toFunc target function\n@param fromFunc source function","static":false,"name":"replaceFunctionParameters","comment":"replaceFunctionParameters replaces the parameters of the\n function in program1 with the parameters of the function in program2\n at the specified entry point address.  It also replaces the return\n type\/storage as well as custom storage use.","params":[{"type_long":"ghidra.program.model.listing.Function","name":"toFunc","comment":"target function","type_short":"Function"},{"type_long":"ghidra.program.model.listing.Function","name":"fromFunc","comment":"source function","type_short":"Function"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Create a name that is unique in both namespaces of the given symbolTable.\n@param symbolTable the symbolTable where the symbol will be created.\n@param name the desired name. This name will be given a conflict suffix if necessary\n to make it unique.\n@param address the address of the symbol.\n@param namespace1 the first namespace where the new symbol should be unique. \n This namespace must be from the same program as the symbol table.\n@param namespace2 the second namespace where the new symbol should be unique.\n This namespace must be from the same program as the symbol table.\n@param type the symbol type of the symbol.\n@return a unique name for both namespaces.","static":true,"name":"getUniqueName","comment":"Create a name that is unique in both namespaces of the given symbolTable.","params":[{"type_long":"ghidra.program.model.symbol.SymbolTable","name":"symbolTable","comment":"the symbolTable where the symbol will be created.","type_short":"SymbolTable"},{"type_long":"java.lang.String","name":"name","comment":"the desired name. This name will be given a conflict suffix if necessary\n to make it unique.","type_short":"String"},{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address of the symbol.","type_short":"Address"},{"type_long":"ghidra.program.model.symbol.Namespace","name":"namespace1","comment":"the first namespace where the new symbol should be unique. \n This namespace must be from the same program as the symbol table.","type_short":"Namespace"},{"type_long":"ghidra.program.model.symbol.Namespace","name":"namespace2","comment":"the second namespace where the new symbol should be unique.\n This namespace must be from the same program as the symbol table.","type_short":"Namespace"},{"type_long":"ghidra.program.model.symbol.SymbolType","name":"type","comment":"the symbol type of the symbol.","type_short":"SymbolType"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"a unique name for both namespaces.","type_short":"String"}},{"javadoc":"Create a name that is unique in the indicated namespace of the symbol table.\n@param symbolTable the symbolTable where the symbol will be created.\n@param name the desired name. This name will be given a conflict suffix if necessary\n to make it unique.\n@param address the address of the symbol.\n@param namespace the namespace where the new symbol would be created.\n This namespace must be from the same program as the symbol table.\n@param type the type of symbol.\n@return a unique name within the namespace.","static":true,"name":"getUniqueName","comment":"Create a name that is unique in the indicated namespace of the symbol table.","params":[{"type_long":"ghidra.program.model.symbol.SymbolTable","name":"symbolTable","comment":"the symbolTable where the symbol will be created.","type_short":"SymbolTable"},{"type_long":"java.lang.String","name":"name","comment":"the desired name. This name will be given a conflict suffix if necessary\n to make it unique.","type_short":"String"},{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address of the symbol.","type_short":"Address"},{"type_long":"ghidra.program.model.symbol.Namespace","name":"namespace","comment":"the namespace where the new symbol would be created.\n This namespace must be from the same program as the symbol table.","type_short":"Namespace"},{"type_long":"ghidra.program.model.symbol.SymbolType","name":"type","comment":"the type of symbol.","type_short":"SymbolType"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"a unique name within the namespace.","type_short":"String"}},{"javadoc":"Replaces the external result function with the origin Function.\n <br>Note: This method will replace the function, but does not create\n the parent namespace or put the function in the parent namespace.\n This must be done separately.\n@param toFunction the result function to replace.\n@param fromFunction the function to use as the model when replacing the result function.\n@param monitor the task monitor for notifying the user of this merge's progress.\n@return the new function that was created in the resultListing or null\n if no function was created. If null is returned you should call\n getErrorMessage() to see if an error occurred.\n@throws CancelledException if user cancels via the monitor.\n@throws UnsupportedOperationException if the ProgramMerge translators are not\n \"one for one translators\".","static":false,"name":"replaceExternalFunction","comment":"Replaces the external result function with the origin Function.\n Note: This method will replace the function, but does not create\n the parent namespace or put the function in the parent namespace.\n This must be done separately.","params":[{"type_long":"ghidra.program.model.listing.Function","name":"toFunction","comment":"the result function to replace.","type_short":"Function"},{"type_long":"ghidra.program.model.listing.Function","name":"fromFunction","comment":"the function to use as the model when replacing the result function.","type_short":"Function"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if user cancels via the monitor.","type_short":"CancelledException"},{"type_long":"java.lang.UnsupportedOperationException","comment":"if the ProgramMerge translators are not\n \"one for one translators\".","type_short":"UnsupportedOperationException"}],"return":{"type_long":"ghidra.program.model.listing.Function","comment":"the new function that was created in the resultListing or null\n if no function was created. If null is returned you should call\n getErrorMessage() to see if an error occurred.","type_short":"Function"}},{"javadoc":"<CODE>replaceFunctionParameterName<\/CODE> replaces the name of the indicated\n function parameter in program1 with the name from the origin program.\n@param originEntryPoint the entry point address of the function to modify.\n This address should be derived from the origin program.\n@param ordinal the index of the parameter to change.\n@param monitor the task monitor for notifying the user of progress.\n@throws InvalidInputException\n@throws DuplicateNameException","static":false,"name":"replaceFunctionParameterName","comment":"replaceFunctionParameterName replaces the name of the indicated\n function parameter in program1 with the name from the origin program.","params":[{"type_long":"ghidra.program.model.address.Address","name":"originEntryPoint","comment":"the entry point address of the function to modify.\n This address should be derived from the origin program.","type_short":"Address"},{"type_long":"int","name":"ordinal","comment":"the index of the parameter to change.","type_short":"int"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.DuplicateNameException","comment":"","type_short":"DuplicateNameException"},{"type_long":"ghidra.util.exception.InvalidInputException","comment":"","type_short":"InvalidInputException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>replaceFunctionParameterDataType<\/CODE> replaces the data type of the indicated\n function parameter in program1 with the data type from the origin program.\n@param originEntryPoint the entry point address of the function to modify.\n This address should be derived from the origin program.\n@param ordinal the index of the parameter to change.\n@param monitor the task monitor for notifying the user of progress.","static":false,"name":"replaceFunctionParameterDataType","comment":"replaceFunctionParameterDataType replaces the data type of the indicated\n function parameter in program1 with the data type from the origin program.","params":[{"type_long":"ghidra.program.model.address.Address","name":"originEntryPoint","comment":"the entry point address of the function to modify.\n This address should be derived from the origin program.","type_short":"Address"},{"type_long":"int","name":"ordinal","comment":"the index of the parameter to change.","type_short":"int"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of progress.","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>replaceFunctionParameterComment<\/CODE> replaces the comment of the indicated\n function parameter in program1 with the comment from the origin program.\n@param originEntryPoint the entry point address of the function to modify.\n This address should be derived from the origin program.\n@param ordinal the index of the parameter to change.\n@param monitor the task monitor for notifying the user of progress.","static":false,"name":"replaceFunctionParameterComment","comment":"replaceFunctionParameterComment replaces the comment of the indicated\n function parameter in program1 with the comment from the origin program.","params":[{"type_long":"ghidra.program.model.address.Address","name":"originEntryPoint","comment":"the entry point address of the function to modify.\n This address should be derived from the origin program.","type_short":"Address"},{"type_long":"int","name":"ordinal","comment":"the index of the parameter to change.","type_short":"int"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of progress.","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>replaceFunctionVariable<\/CODE> replaces the name of the indicated\n function variable in program1 with that from the origin program.\n@param entry the entry point address of the function to modify.\n This address should be derived from program1.\n@param var a variable that is equivalent to the one in program1 to be replaced.\n The variable passed here could be from another program.\n@param monitor the task monitor for notifying the user of progress.\n@throws DuplicateNameException","static":false,"name":"replaceFunctionVariable","comment":"replaceFunctionVariable replaces the name of the indicated\n function variable in program1 with that from the origin program.","params":[{"type_long":"ghidra.program.model.address.Address","name":"originEntryPoint","comment":"","type_short":"Address"},{"type_long":"ghidra.program.model.listing.Variable","name":"var","comment":"a variable that is equivalent to the one in program1 to be replaced.\n The variable passed here could be from another program.","type_short":"Variable"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of progress.","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>replaceFunctionVariables<\/CODE> replaces the\n function variables\/parameters in program1 with that from the origin program.\n@param entry the entry point address of the function to modify.\n This address should be derived from program1.\n@param var a variable that is equivalent to the one in program1 to be replaced.\n The variable passed here could be from another program.\n@param monitor the task monitor for notifying the user of progress.\n@throws DuplicateNameException","static":false,"name":"replaceVariables","comment":"replaceFunctionVariables replaces the\n function variables\/parameters in program1 with that from the origin program.","params":[{"type_long":"ghidra.program.model.address.Address","name":"originEntryPoint","comment":"","type_short":"Address"},{"type_long":"java.util.List<ghidra.program.model.listing.Variable>","name":"varList","comment":"","type_short":"List"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>replaceFunctionVariableName<\/CODE> replaces the name on the indicated\n function variable in program1 with the name from the equivalent variable in program2.\n@param originEntryPoint the entry point address of the function to modify.\n This address should be derived from the origin program.\n@param var a variable that is equivalent to the one in program1 to be changed.\n The variable passed here could be from another program.\n@param monitor the task monitor for notifying the user of progress.\n@throws InvalidInputException\n@throws DuplicateNameException","static":false,"name":"replaceFunctionVariableName","comment":"replaceFunctionVariableName replaces the name on the indicated\n function variable in program1 with the name from the equivalent variable in program2.","params":[{"type_long":"ghidra.program.model.address.Address","name":"originEntryPoint","comment":"the entry point address of the function to modify.\n This address should be derived from the origin program.","type_short":"Address"},{"type_long":"ghidra.program.model.listing.Variable","name":"var","comment":"a variable that is equivalent to the one in program1 to be changed.\n The variable passed here could be from another program.","type_short":"Variable"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.DuplicateNameException","comment":"","type_short":"DuplicateNameException"},{"type_long":"ghidra.util.exception.InvalidInputException","comment":"","type_short":"InvalidInputException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>replaceFunctionVariableDataType<\/CODE> replaces the data type on the indicated\n function variable in program1 with the data type from the equivalent variable in program2.\n@param originEntryPoint the entry point address of the function to modify.\n This address should be derived from the origin program.\n@param var a variable that is equivalent to the one in program1 to be changed.\n The variable passed here could be from another program.\n@param monitor the task monitor for notifying the user of progress.","static":false,"name":"replaceFunctionVariableDataType","comment":"replaceFunctionVariableDataType replaces the data type on the indicated\n function variable in program1 with the data type from the equivalent variable in program2.","params":[{"type_long":"ghidra.program.model.address.Address","name":"originEntryPoint","comment":"the entry point address of the function to modify.\n This address should be derived from the origin program.","type_short":"Address"},{"type_long":"ghidra.program.model.listing.Variable","name":"var","comment":"a variable that is equivalent to the one in program1 to be changed.\n The variable passed here could be from another program.","type_short":"Variable"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of progress.","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>replaceFunctionVariableComment<\/CODE> replaces the comment on the indicated\n function variable in program1 with the comment from the equivalent variable in program2.\n@param originEntryPoint entry point address of the function whose variable is getting the comment replaced.\n This address should be derived from the origin program.\n@param var a variable that is equivalent to the one in program1 to be changed.\n The variable passed here could be from another program.\n@param monitor the task monitor for notifying the user of progress.","static":false,"name":"replaceFunctionVariableComment","comment":"replaceFunctionVariableComment replaces the comment on the indicated\n function variable in program1 with the comment from the equivalent variable in program2.","params":[{"type_long":"ghidra.program.model.address.Address","name":"originEntryPoint","comment":"entry point address of the function whose variable is getting the comment replaced.\n This address should be derived from the origin program.","type_short":"Address"},{"type_long":"ghidra.program.model.listing.Variable","name":"var","comment":"a variable that is equivalent to the one in program1 to be changed.\n The variable passed here could be from another program.","type_short":"Variable"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of progress.","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>mergeBookmark<\/CODE> merges the indicated bookmark from the origin program into the\n result program at an address equivalent to the originAddress.\n Merging means replace any existing bookmark of the specified type for NOTEs\n or of the specified type and category for non-NOTE types.\n <p>Note: This method merges a single bookmark without affecting\n other bookmarks at the indicated address.\n@param originAddress the address in the origin program where the bookmark is to be merged.\n@param type indicates the type of bookmark to merge.\n@param category indicates the category of the bookmark.\n@param monitor a task monitor for providing feedback to the user.\n@throws CancelledException if the user cancels the bookmark merge from the monitor dialog.","static":false,"name":"mergeBookmark","comment":"mergeBookmark merges the indicated bookmark from the origin program into the\n result program at an address equivalent to the originAddress.\n Merging means replace any existing bookmark of the specified type for NOTEs\n or of the specified type and category for non-NOTE types.\n Note: This method merges a single bookmark without affecting\n other bookmarks at the indicated address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"originAddress","comment":"the address in the origin program where the bookmark is to be merged.","type_short":"Address"},{"type_long":"java.lang.String","name":"type","comment":"indicates the type of bookmark to merge.","type_short":"String"},{"type_long":"java.lang.String","name":"category","comment":"indicates the category of the bookmark.","type_short":"String"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"a task monitor for providing feedback to the user.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if the user cancels the bookmark merge from the monitor dialog.","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>mergeProperties<\/CODE> merges user defined property differences\n  within the specified address set.\n@param originAddressSet the addresses to be merged from the origin program.\n@param monitor the task monitor for notifying the user of this merge's progress.\n@throws CancelledException if user cancels via the monitor.\n@throws UnsupportedOperationException if the ProgramMerge translator is not a\n \"one for one translator\".","static":false,"name":"mergeProperties","comment":"mergeProperties merges user defined property differences\n  within the specified address set.","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"originAddressSet","comment":"the addresses to be merged from the origin program.","type_short":"AddressSetView"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if user cancels via the monitor.","type_short":"CancelledException"},{"type_long":"java.lang.UnsupportedOperationException","comment":"if the ProgramMerge translator is not a\n \"one for one translator\".","type_short":"UnsupportedOperationException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Replaces the user defined properties from the specified origin address in the origin program\n to the equivalent result address in the result program.\n Note: To merge properties, there must be a code unit AT the equivalent address\n in the result program.\n@param originAddress the address of the code unit to get the properties from in the origin program.","static":false,"name":"mergeUserProperty","comment":"Replaces the user defined properties from the specified origin address in the origin program\n to the equivalent result address in the result program.\n Note: To merge properties, there must be a code unit AT the equivalent address\n in the result program.","params":[{"type_long":"java.lang.String","name":"userPropertyName","comment":"","type_short":"String"},{"type_long":"ghidra.program.model.address.Address","name":"originAddress","comment":"the address of the code unit to get the properties from in the origin program.","type_short":"Address"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Set the property on the merge program's code unit if the named property\n  is a void property type.","static":false,"name":"visit","comment":"Set the property on the merge program's code unit if the named property\n  is a void property type.","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Set the property on the merge program's code unit if the named property\n  is a String property type.\n@param value the value for the named property.","static":false,"name":"visit","comment":"Set the property on the merge program's code unit if the named property\n  is a String property type.","params":[{"type_long":"java.lang.String","name":"value","comment":"the value for the named property.","type_short":"String"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Set the property on the merge program's code unit if the named property\n  is an Object property type.\n@param value the value for the named property.","static":false,"name":"visit","comment":"Set the property on the merge program's code unit if the named property\n  is an Object property type.","params":[{"type_long":"java.lang.Object","name":"value","comment":"the value for the named property.","type_short":"Object"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Set the property on the merge program's code unit if the named property\n  is an Object property type.\n@param value the value for the named property.","static":false,"name":"visit","comment":"Set the property on the merge program's code unit if the named property\n  is an Object property type.","params":[{"type_long":"ghidra.util.Saveable","name":"value","comment":"the value for the named property.","type_short":"Saveable"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Set the property on the merge program's code unit if the named property\n  is an int property type.\n@param value the value for the named property.","static":false,"name":"visit","comment":"Set the property on the merge program's code unit if the named property\n  is an int property type.","params":[{"type_long":"int","name":"value","comment":"the value for the named property.","type_short":"int"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}}],"name":"ProgramMerge","comment":"ProgramMerge is a class for merging the differences between two\n programs. The differences are merged from program2 into program1.\n Program1 is the program being modified by the merge. Program2 is source\n for obtaining differences to apply to program1.\n If name conflicts occur while merging, the item (for example, symbol) will\n be merged with a new name that consists of the original name followed by \"_conflict\"\n and a one up number.","fields":[{"type_long":"java.lang.String","javadoc":"Suffix that is attached to a symbol name and then followed by a number to create a new unique symbol name.","static":true,"name":"SYMBOL_CONFLICT_SUFFIX","comment":"Suffix that is attached to a symbol name and then followed by a number to create a new unique symbol name.","type_short":"String","constant_value":null}]}
