{"implements":[],"javadoc":"","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"","static":false,"name":"<init>","comment":"","params":[{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"","type_short":"Program"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"setDebug","comment":"","params":[{"type_long":"boolean","name":"debug","comment":"","type_short":"boolean"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Process a subroutine using the processor function.\n The process function can control what flows are followed and when to stop.\n@param entryPoint start address\n@param processor processor to use\n@return the address set of instructions that were followed\n@throws CancelledException","static":false,"name":"flowConstants","comment":"Process a subroutine using the processor function.\n The process function can control what flows are followed and when to stop.","params":[{"type_long":"ghidra.program.model.address.Address","name":"startAddr","comment":"","type_short":"Address"},{"type_long":"ghidra.program.model.address.AddressSetView","name":"restrictSet","comment":"","type_short":"AddressSetView"},{"type_long":"ghidra.program.util.ContextEvaluator","name":"eval","comment":"","type_short":"ContextEvaluator"},{"type_long":"boolean","name":"saveContext","comment":"","type_short":"boolean"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"ghidra.program.model.address.AddressSet","comment":"the address set of instructions that were followed","type_short":"AddressSet"}},{"javadoc":"Get constant or register relative value assigned to the \n specified register at the specified address\n@param addr address\n@param reg register\n@return register value","static":false,"name":"getRegisterValue","comment":"Get constant or register relative value assigned to the \n specified register at the specified address","params":[{"type_long":"ghidra.program.model.address.Address","name":"toAddr","comment":"","type_short":"Address"},{"type_long":"ghidra.program.model.lang.Register","name":"reg","comment":"register","type_short":"Register"}],"throws":[],"return":{"type_long":"ghidra.program.util.SymbolicPropogator.Value","comment":"register value","type_short":"Value"}},{"javadoc":"Do not depend on this method!  For display debugging purposes only.\n This will change.\n@param addr\n@param reg\n@return ","static":false,"name":"getRegisterValueRepresentation","comment":"Do not depend on this method!  For display debugging purposes only.\n This will change.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"","type_short":"Address"},{"type_long":"ghidra.program.model.lang.Register","name":"reg","comment":"","type_short":"Register"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"","static":false,"name":"setRegister","comment":"","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"","type_short":"Address"},{"type_long":"ghidra.program.model.lang.Register","name":"stackReg","comment":"","type_short":"Register"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"flowConstants","comment":"","params":[{"type_long":"ghidra.program.model.address.Address","name":"startAddr","comment":"","type_short":"Address"},{"type_long":"ghidra.program.model.address.AddressSetView","name":"restrictSet","comment":"","type_short":"AddressSetView"},{"type_long":"ghidra.program.util.ContextEvaluator","name":"eval","comment":"","type_short":"ContextEvaluator"},{"type_long":"ghidra.program.util.VarnodeContext","name":"vContext","comment":"","type_short":"VarnodeContext"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"ghidra.program.model.address.AddressSet","comment":"","type_short":"AddressSet"}},{"javadoc":"","static":false,"name":"flowConstants","comment":"","params":[{"type_long":"ghidra.program.model.address.Address","name":"fromAddr","comment":"","type_short":"Address"},{"type_long":"ghidra.program.model.address.Address","name":"startAddr","comment":"","type_short":"Address"},{"type_long":"ghidra.program.model.address.AddressSetView","name":"restrictSet","comment":"","type_short":"AddressSetView"},{"type_long":"ghidra.program.util.ContextEvaluator","name":"eval","comment":"","type_short":"ContextEvaluator"},{"type_long":"ghidra.program.util.VarnodeContext","name":"vContext","comment":"","type_short":"VarnodeContext"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"ghidra.program.model.address.AddressSet","comment":"","type_short":"AddressSet"}},{"javadoc":"Make from the instruction to the reference based on the varnode passed in.\n@param varnodeContext - context to use for any other infomation needed\n@param instruction - instruction to place the reference on.\n@param pcodeop - pcode op that caused the reference\n@param opIndex - operand it should be placed on, or -1 if unknown\n@param vt - place to reference, could be a full address, or just a constant\n@param refType - type of reference\n@param monitor","static":false,"name":"makeReference","comment":"Make from the instruction to the reference based on the varnode passed in.","params":[{"type_long":"ghidra.program.util.VarnodeContext","name":"varnodeContext","comment":"- context to use for any other infomation needed","type_short":"VarnodeContext"},{"type_long":"ghidra.program.model.listing.Instruction","name":"instruction","comment":"- instruction to place the reference on.","type_short":"Instruction"},{"type_long":"int","name":"pcodeop","comment":"- pcode op that caused the reference","type_short":"int"},{"type_long":"int","name":"opIndex","comment":"- operand it should be placed on, or -1 if unknown","type_short":"int"},{"type_long":"ghidra.program.model.pcode.Varnode","name":"vt","comment":"- place to reference, could be a full address, or just a constant","type_short":"Varnode"},{"type_long":"ghidra.program.model.symbol.RefType","name":"refType","comment":"- type of reference","type_short":"RefType"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Make a reference from the instruction to the address based on the spaceID,offset passed in.\n   This could make a reference into an overlay (overriding the spaceID), or into memory, if\n   spaceID is a constant space.\n  The target could be an external Address carried along and then finally used.\n  External addresses are OK as long as nothing is done to the offset.\n@param varnodeContext - context to use for any other infomation needed\n@param instruction - instruction to place the reference on.\n@param opIndex - operand it should be placed on, or -1 if unknown\n@param spaceID target space ID or -1 if only offset is known\n@param wordOffset - target offset that is word addressing based\n@param refType - type of reference\n@param pcodeop - pcode op that caused the reference\n@param monitor","static":false,"name":"makeReference","comment":"Make a reference from the instruction to the address based on the spaceID,offset passed in.\n   This could make a reference into an overlay (overriding the spaceID), or into memory, if\n   spaceID is a constant space.\n  The target could be an external Address carried along and then finally used.\n  External addresses are OK as long as nothing is done to the offset.","params":[{"type_long":"ghidra.program.util.VarnodeContext","name":"vContext","comment":"","type_short":"VarnodeContext"},{"type_long":"ghidra.program.model.listing.Instruction","name":"instruction","comment":"- instruction to place the reference on.","type_short":"Instruction"},{"type_long":"int","name":"opIndex","comment":"- operand it should be placed on, or -1 if unknown","type_short":"int"},{"type_long":"long","name":"knownSpaceID","comment":"","type_short":"long"},{"type_long":"long","name":"wordOffset","comment":"- target offset that is word addressing based","type_short":"long"},{"type_long":"int","name":"size","comment":"","type_short":"int"},{"type_long":"ghidra.program.model.symbol.RefType","name":"refType","comment":"- type of reference","type_short":"RefType"},{"type_long":"int","name":"pcodeop","comment":"- pcode op that caused the reference","type_short":"int"},{"type_long":"boolean","name":"knownReference","comment":"","type_short":"boolean"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"@return true if any branching instructions have been encountered","static":false,"name":"encounteredBranch","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if any branching instructions have been encountered","type_short":"boolean"}},{"javadoc":"@return return true if the code ever read from an executable location","static":false,"name":"readExecutable","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"return true if the code ever read from an executable location","type_short":"boolean"}},{"javadoc":"enable\/disable checking parameters for constant references\n@param checkParamRefsOption true to enable","static":false,"name":"setParamRefCheck","comment":"enable\/disable checking parameters for constant references","params":[{"type_long":"boolean","name":"checkParamRefsOption","comment":"true to enable","type_short":"boolean"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"enable\/disable checking return for constant references\n@param checkReturnRefsOption","static":false,"name":"setReturnRefCheck","comment":"enable\/disable checking return for constant references","params":[{"type_long":"boolean","name":"checkReturnRefsOption","comment":"","type_short":"boolean"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"enable\/disable checking stored values for constant references\n@param checkStoredRefsOption","static":false,"name":"setStoredRefCheck","comment":"enable\/disable checking stored values for constant references","params":[{"type_long":"boolean","name":"checkStoredRefsOption","comment":"","type_short":"boolean"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}}],"name":"SymbolicPropogator","comment":"","fields":[]}
