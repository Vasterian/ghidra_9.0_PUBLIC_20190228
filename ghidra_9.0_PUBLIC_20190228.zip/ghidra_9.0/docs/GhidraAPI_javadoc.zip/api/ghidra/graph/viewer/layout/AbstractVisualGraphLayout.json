{"implements":["ghidra.graph.viewer.layout.VisualGraphLayout"],"javadoc":"A base layout that marries the Visual Graph and Jung layout interfaces.   This class allows\n you to create new layouts while stubbing the Jung layout methods.\n\n <P>This class essentially takes in client-produced grid row and column indices and \n produces layout locations for those values.\n\n <P>This an implementation the Jung {@link Layout} interface that handles most of the \n layout implementation for you.  Things to know:\n <UL>\n \t<LI>You should call initialize() inside of your constructor<\/LI>\n  <LI>You must implement {@link #performInitialGridLayout(VisualGraph)} - this is where \n      you align your vertices (and optionally edge articulations) on a grid.  This grid\n      will be translated into layout space points for you.<\/LI>\n  <LI>If you wish to use articulation points in your edges, you must override \n      {@link #usesEdgeArticulations()} to return true.<\/LI> \n <\/UL>\n \n <p><A NAME=\"column_centering\"><\/A>By default, this class will create x-position values that\n are aligned with the column's x-position.   You can override \n {@link #getVertexLocation(VisualVertex, Column, Row, Rectangle)} in order to center the\n vertex within its column\n {@link #getCenteredVertexLocation(VisualVertex, Column, Row, Rectangle)}.  Also note though \n that if your layout returns true for {@link #isCondensedLayout()},\n then the centering will be condensed and slightly off.\n@param <V> the vertex type\n@param <E> the edge type\n@see GridLocationMap\n@see LayoutPositions","static":false,"extends":"edu.uci.ics.jung.algorithms.layout.AbstractLayout","methods":[{"javadoc":"","static":false,"name":"setTaskMonitor","comment":"","params":[{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"getEdgeRenderer","comment":"","params":[],"throws":[],"return":{"type_long":"edu.uci.ics.jung.visualization.renderers.BasicEdgeRenderer<V,E>","comment":"","type_short":"BasicEdgeRenderer"}},{"javadoc":"","static":false,"name":"getEdgeShapeTransformer","comment":"","params":[],"throws":[],"return":{"type_long":"com.google.common.base.Function<E,java.awt.Shape>","comment":"","type_short":"Function"}},{"javadoc":"","static":false,"name":"getEdgeLabelRenderer","comment":"","params":[],"throws":[],"return":{"type_long":"edu.uci.ics.jung.visualization.renderers.Renderer.EdgeLabel<V,E>","comment":"","type_short":"EdgeLabel"}},{"javadoc":"","static":false,"name":"usesEdgeArticulations","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":false,"name":"reset","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"dispose","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"initialize","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"calculateLocations","comment":"","params":[{"type_long":"ghidra.graph.VisualGraph<V,E>","name":"visualGraph","comment":"","type_short":"VisualGraph"},{"type_long":"ghidra.util.task.TaskMonitor","name":"taskMonitor","comment":"","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"ghidra.graph.viewer.layout.LayoutPositions<V,E>","comment":"","type_short":"LayoutPositions"}},{"javadoc":"This class has implemented {@link #cloneLayout(VisualGraph)} in order to properly \n initialize location information in the layout so that subclasses do not have to.  Each\n subclass still needs to create the new instance of the layout that is being cloned, as\n this class does not know how to do so.\n@param newGraph the new graph for the new layout\n@return the new layout","static":false,"name":"createClonedLayout","comment":"This class has implemented #cloneLayout(VisualGraph) in order to properly \n initialize location information in the layout so that subclasses do not have to.  Each\n subclass still needs to create the new instance of the layout that is being cloned, as\n this class does not know how to do so.","params":[{"type_long":"ghidra.graph.VisualGraph<V,E>","name":"newGraph","comment":"the new graph for the new layout","type_short":"VisualGraph"}],"throws":[],"return":{"type_long":"ghidra.graph.viewer.layout.AbstractVisualGraphLayout<V,E>","comment":"the new layout","type_short":"AbstractVisualGraphLayout"}},{"javadoc":"","static":false,"name":"cloneLayout","comment":"","params":[{"type_long":"ghidra.graph.VisualGraph<V,E>","name":"newGraph","comment":"","type_short":"VisualGraph"}],"throws":[],"return":{"type_long":"ghidra.graph.viewer.layout.VisualGraphLayout<V,E>","comment":"","type_short":"VisualGraphLayout"}},{"javadoc":"","static":false,"name":"addLayoutListener","comment":"","params":[{"type_long":"ghidra.graph.viewer.layout.LayoutListener<V,E>","name":"listener","comment":"","type_short":"LayoutListener"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"removeLayoutListener","comment":"","params":[{"type_long":"ghidra.graph.viewer.layout.LayoutListener<V,E>","name":"listener","comment":"","type_short":"LayoutListener"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"setLocation","comment":"","params":[{"type_long":"V","name":"v","comment":"","type_short":"V"},{"type_long":"java.awt.geom.Point2D","name":"location","comment":"","type_short":"Point2D"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"setLocation","comment":"","params":[{"type_long":"V","name":"v","comment":"","type_short":"V"},{"type_long":"java.awt.geom.Point2D","name":"location","comment":"","type_short":"Point2D"},{"type_long":"ghidra.graph.viewer.layout.LayoutListener.ChangeType","name":"changeType","comment":"","type_short":"ChangeType"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}}],"name":"AbstractVisualGraphLayout","comment":"A base layout that marries the Visual Graph and Jung layout interfaces.   This class allows\n you to create new layouts while stubbing the Jung layout methods.\n\n This class essentially takes in client-produced grid row and column indices and \n produces layout locations for those values.\n\n This an implementation the Jung Layout interface that handles most of the \n layout implementation for you.  Things to know:\n \n \tYou should call initialize() inside of your constructor\n  You must implement #performInitialGridLayout(VisualGraph) - this is where \n      you align your vertices (and optionally edge articulations) on a grid.  This grid\n      will be translated into layout space points for you.\n  If you wish to use articulation points in your edges, you must override \n      #usesEdgeArticulations() to return true. \n \n \n By default, this class will create x-position values that\n are aligned with the column's x-position.   You can override \n #getVertexLocation(VisualVertex, Column, Row, Rectangle) in order to center the\n vertex within its column\n #getCenteredVertexLocation(VisualVertex, Column, Row, Rectangle).  Also note though \n that if your layout returns true for #isCondensedLayout(),\n then the centering will be condensed and slightly off.","fields":[]}
