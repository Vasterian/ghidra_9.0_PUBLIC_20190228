{"implements":[],"javadoc":"","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"","static":false,"name":"<init>","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":true,"name":"createToolbarSeparator","comment":"","params":[],"throws":[],"return":{"type_long":"javax.swing.JSeparator","comment":"","type_short":"JSeparator"}},{"javadoc":"","static":true,"name":"scaleIconAsNeeded","comment":"","params":[{"type_long":"javax.swing.Icon","name":"icon","comment":"","type_short":"Icon"}],"throws":[],"return":{"type_long":"javax.swing.Icon","comment":"","type_short":"Icon"}},{"javadoc":"Checks if the mouseEvent has the \"control\" key down.  On windows, this is actually\n the <tt>control<\/tt> key.  On Mac, it is the <tt>command<\/tt> key.\n@param mouseEvent the event to check\n@return true if the control key is pressed","static":true,"name":"isControlModifier","comment":"Checks if the mouseEvent has the \"control\" key down.  On windows, this is actually\n the control key.  On Mac, it is the command key.","params":[{"type_long":"java.awt.event.MouseEvent","name":"mouseEvent","comment":"the event to check","type_short":"MouseEvent"}],"throws":[],"return":{"type_long":"boolean","comment":"true if the control key is pressed","type_short":"boolean"}},{"javadoc":"Checks if the mouseEvent has the \"control\" key down.  On windows, this is actually\n the <tt>control<\/tt> key.  On Mac, it is the <tt>command<\/tt> key.\n@param keyEvent the event to check\n@return true if the control key is pressed","static":true,"name":"isControlModifier","comment":"Checks if the mouseEvent has the \"control\" key down.  On windows, this is actually\n the control key.  On Mac, it is the command key.","params":[{"type_long":"java.awt.event.KeyEvent","name":"keyEvent","comment":"the event to check","type_short":"KeyEvent"}],"throws":[],"return":{"type_long":"boolean","comment":"true if the control key is pressed","type_short":"boolean"}},{"javadoc":"","static":true,"name":"installUndoRedo","comment":"","params":[{"type_long":"javax.swing.text.JTextComponent","name":"textComponent","comment":"","type_short":"JTextComponent"}],"throws":[],"return":{"type_long":"docking.UndoRedoKeeper","comment":"","type_short":"UndoRedoKeeper"}},{"javadoc":"Perform some operation on a component and all of its descendants, recursively\n \n This traverses the swing\/awt component tree starting at the given container and descends\n recursively through all containers. Any time a component of type (or subclass of type) is\n found, the given callback is executed on it. If order is\n {@link TreeTraversalOrder#CHILDREN_FIRST}, then the traversal will execute the callback on\n the children of a container before executing the callback on the container itself; if\n {@link TreeTraversalOrder#PARENT_FIRST}, then the traversal will execute the callback on the\n container before descending.\n \n The callback must return one of three result values. In normal circumstances, it should\n return {@link TreeTraversalResult#CONTINUE}, allowing traversal to continue to the next\n element. If the callback wishes to terminate traversal \"successfully,\" e.g., because it\n needed to locate the first element satisfying some predicate, then it should return\n {@link TreeTraversalResult#FINISH}. If an error occurs during traversal, then it should\n either return {@link TreeTraversalResult#TERMINATE} or throw an appropriate exception to\n terminate traversal \"unsuccessfully.\"\n \n This method will also return a value of {@link TreeTraversalResult} indicating how traversal\n terminated. If {@link TreeTraversalResult#CONTINUE}, then every element in the subtree was\n visited, and traversal was successful. If {@link TreeTraversalResult#FINISH}, then some\n elements may have been omitted, but traversal was still successful. If\n {@link TreeTraversalResult#TERMINATE}, then some elements may have been omitted, and\n traversal was not successful.\n@param start the \"root\" container of the subtree on which to operate\n@param type the type of components on which to operate\n@param order whether to operation on children or parents first\n@param cb the callback to perform the actual operation\n@return a result indicating whether or not traversal completed successfully","static":true,"name":"forAllDescendants","comment":"Perform some operation on a component and all of its descendants, recursively\n \n This traverses the swing\/awt component tree starting at the given container and descends\n recursively through all containers. Any time a component of type (or subclass of type) is\n found, the given callback is executed on it. If order is\n TreeTraversalOrder#CHILDREN_FIRST, then the traversal will execute the callback on\n the children of a container before executing the callback on the container itself; if\n TreeTraversalOrder#PARENT_FIRST, then the traversal will execute the callback on the\n container before descending.\n \n The callback must return one of three result values. In normal circumstances, it should\n return TreeTraversalResult#CONTINUE, allowing traversal to continue to the next\n element. If the callback wishes to terminate traversal \"successfully,\" e.g., because it\n needed to locate the first element satisfying some predicate, then it should return\n TreeTraversalResult#FINISH. If an error occurs during traversal, then it should\n either return TreeTraversalResult#TERMINATE or throw an appropriate exception to\n terminate traversal \"unsuccessfully.\"\n \n This method will also return a value of TreeTraversalResult indicating how traversal\n terminated. If TreeTraversalResult#CONTINUE, then every element in the subtree was\n visited, and traversal was successful. If TreeTraversalResult#FINISH, then some\n elements may have been omitted, but traversal was still successful. If\n TreeTraversalResult#TERMINATE, then some elements may have been omitted, and\n traversal was not successful.","params":[{"type_long":"java.awt.Container","name":"start","comment":"the \"root\" container of the subtree on which to operate","type_short":"Container"},{"type_long":"java.lang.Class<T>","name":"type","comment":"the type of components on which to operate","type_short":"Class"},{"type_long":"docking.DockingUtils.TreeTraversalOrder","name":"order","comment":"whether to operation on children or parents first","type_short":"TreeTraversalOrder"},{"type_long":"docking.DockingUtils.ComponentCallback<T>","name":"cb","comment":"the callback to perform the actual operation","type_short":"ComponentCallback"}],"throws":[],"return":{"type_long":"docking.DockingUtils.TreeTraversalResult","comment":"a result indicating whether or not traversal completed successfully","type_short":"TreeTraversalResult"}},{"javadoc":"Perform some operation on a component and all of its descendents, recursively.\n \n This applies the operation to all components in the tree, children first.\n@param start the \"root\" container of the subtree on which to operate\n@param cb the callback to perform the actual operation\n@return a result indicating whether or not traversal completed successfully\n@see DockingUtils#forAllDescendants(Container, Class, TreeTraversalOrder, ComponentCallback)","static":true,"name":"forAllDescendants","comment":"Perform some operation on a component and all of its descendents, recursively.\n \n This applies the operation to all components in the tree, children first.","params":[{"type_long":"java.awt.Container","name":"start","comment":"the \"root\" container of the subtree on which to operate","type_short":"Container"},{"type_long":"docking.DockingUtils.ComponentCallback<java.awt.Component>","name":"cb","comment":"the callback to perform the actual operation","type_short":"ComponentCallback"}],"throws":[],"return":{"type_long":"docking.DockingUtils.TreeTraversalResult","comment":"a result indicating whether or not traversal completed successfully","type_short":"TreeTraversalResult"}},{"javadoc":"Sets the given component to transparent, which allows the parent component's background\n to be painted.\n <p>\n <u>Notes<\/u>\n Historically, to make a component transparent you would call \n {@link JComponent#setOpaque(boolean)} with a <tt>false<\/tt> value.  However, it turns out\n that the definition and the implementation of this method are at odds.  <tt>setOpaque(false)<\/tt>\n is meant to signal that some part of the component is transparent, so the parent component\n needs to be painted.  Most LaFs implemented this by not painting the background of the\n component, but used the parent's color instead.  The Nimbus LaF actually honors the \n contract of <tt>setOpaque()<\/tt>, which has the effect of painting the components \n background by default.\n <p>\n This method allows components to achieve transparency when they used to \n rely on <tt>setOpaque(false)<\/tt>.\n@param c the component to be made transparent","static":true,"name":"setTransparent","comment":"Sets the given component to transparent, which allows the parent component's background\n to be painted.\n \n Notes\n Historically, to make a component transparent you would call \n JComponent#setOpaque(boolean) with a false value.  However, it turns out\n that the definition and the implementation of this method are at odds.  setOpaque(false)\n is meant to signal that some part of the component is transparent, so the parent component\n needs to be painted.  Most LaFs implemented this by not painting the background of the\n component, but used the parent's color instead.  The Nimbus LaF actually honors the \n contract of setOpaque(), which has the effect of painting the components \n background by default.\n \n This method allows components to achieve transparency when they used to \n rely on setOpaque(false).","params":[{"type_long":"javax.swing.JComponent","name":"c","comment":"the component to be made transparent","type_short":"JComponent"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}}],"name":"DockingUtils","comment":"","fields":[{"type_long":"int","javadoc":"System dependent mask for the Ctrl key","static":true,"name":"CONTROL_KEY_MODIFIER_MASK","comment":"System dependent mask for the Ctrl key","type_short":"int","constant_value":null},{"type_long":"int","javadoc":"A version the control key modifiers that is based upon the pre-Java 9 {@link InputEvent}\n usage.  This mask is here for those clients that cannot be upgraded, such as those with \n dependencies on 3rd-party libraries that still use the old mask style.\n@deprecated use instead {@link #CONTROL_KEY_MODIFIER_MASK}","static":true,"name":"CONTROL_KEY_MODIFIER_MASK_DEPRECATED","comment":"A version the control key modifiers that is based upon the pre-Java 9 InputEvent\n usage.  This mask is here for those clients that cannot be upgraded, such as those with \n dependencies on 3rd-party libraries that still use the old mask style.","type_short":"int","constant_value":null},{"type_long":"java.lang.String","javadoc":"","static":true,"name":"CONTROL_KEY_NAME","comment":"","type_short":"String","constant_value":null}]}
