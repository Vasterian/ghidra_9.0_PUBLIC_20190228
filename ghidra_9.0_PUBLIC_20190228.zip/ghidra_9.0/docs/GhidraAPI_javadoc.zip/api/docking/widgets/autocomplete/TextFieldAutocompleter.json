{"implements":[],"javadoc":"An autocompleter that may be attached to one or more {@link JTextField}.\n \n Each autocompleter instance has one associated window (displaying the list of suggestions) and\n one associated model (generating the list of suggestions). Thus, the list can only be active on\n one of the attached text fields at a time. This is usually the desired behavior, and it allows\n for one autocompleter to be reused on many fields. Behavior is undefined when multiple\n autocompleters are attached to the same text field. More likely, you should implement a\n composite model if you wish to present completions from multiple models on a single text field.\n \n By default, the autocompleter is activated when the user presses CTRL-SPACE, at which point, the\n model is queried for possible suggestions. The completer gives the model all the text preceding\n the current field's caret. This behavior can be changed by overriding the\n {@link #getPrefix(JTextField)} method. This may be useful, e.g., to obtain a prefix for\n the current word, rather than the full field contents, preceding the caret. The list is\n displayed such that its top-left corner is placed directly under the current field's caret. As\n the user continues typing, the suggestions are re-computed, and the list tracks with the caret.\n This positioning behavior can be modified by overriding the\n {@link #getCompletionWindowPosition()} method. As a convenience, the\n {@link #getCaretPositionOnScreen(JTextField)} method is available to compute the default\n position.\n \n Whether or not the list is currently displayed, when the user presses CTRL-SPACE, if only one\n completion is possible, it is automatically activated. This logic is applied again and again,\n until either no suggestions are given, or more than one suggestion is given (or until the\n autocompleter detects an infinite loop). This behavior can by modified on an item-by-item basis\n by overriding the {@link #getCompletionCanDefault(T)} method. This same behavior can be\n activated by calling the {@link #startCompletion(JTextField)} method, which may be useful, e.g.,\n to bind a different key sequence to start autocompletion.\n \n The appearance of each item in the suggestion list can be modified by overriding the various\n {@code getCompletion...} methods. Note that it's possible for an item to be displayed one way,\n but cause the insertion of different text. In any case, it is best to ensure any modification\n produces an intuitive behavior.\n \n The simplest use case is to create a text field, create an autocompleter with a custom model,\n and then attach and show.\n \n {@code\n <pre>\n JTextField field = new JTextField();\n \n AutocompletionModel<String> model = new AutocompletionModel<String>() {\n@Override public Collection<String> computeCompletions(String text) {\n         ... \/\/ Populate the completion list based on the given prefix.\n     }\n }\n TextFieldAutocompleter<String> completer = new TextFieldAutocompleter<String>(model);\n completer.attachTo(field);\n ... \/\/ Add the field to, e.g., a dialog, and show.\n <\/pre>\n }\n@param <T> the type of suggestions presented by this autocompleter.","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"","static":false,"name":"dispose","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Create a new autocompleter associated with the given model.\n@param model the model giving the suggestions.","static":false,"name":"<init>","comment":"Create a new autocompleter associated with the given model.","params":[{"type_long":"docking.widgets.autocomplete.AutocompletionModel<T>","name":"model","comment":"the model giving the suggestions.","type_short":"AutocompletionModel"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Recompute the display location and move with list window.\n \n This is useful, e.g., when the window containing the associated text field(s) moves.","static":false,"name":"updateDisplayLocation","comment":"Recompute the display location and move with list window.\n \n This is useful, e.g., when the window containing the associated text field(s) moves.","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Show or hide the completion list window\n@param visible true to show, false to hide","static":false,"name":"setCompletionListVisible","comment":"Show or hide the completion list window","params":[{"type_long":"boolean","name":"visible","comment":"true to show, false to hide","type_short":"boolean"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Check if the completion list window is visible.\n \n If it is visible, this implies that the user is actively using the autocompleter.\n@return true if shown, false if hidden.","static":false,"name":"isCompletionListVisible","comment":"Check if the completion list window is visible.\n \n If it is visible, this implies that the user is actively using the autocompleter.","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if shown, false if hidden.","type_short":"boolean"}},{"javadoc":"Attach the autocompleter to the given text field.\n \n If this method is never called, then the autocompleter can never appear.\n@param field the field that will gain this autocompletion feature\n@return true, if this field is not already attached","static":false,"name":"attachTo","comment":"Attach the autocompleter to the given text field.\n \n If this method is never called, then the autocompleter can never appear.","params":[{"type_long":"javax.swing.JTextField","name":"field","comment":"the field that will gain this autocompletion feature","type_short":"JTextField"}],"throws":[],"return":{"type_long":"boolean","comment":"true, if this field is not already attached","type_short":"boolean"}},{"javadoc":"Deprive the given field of this autocompleter.\n@param field the field that will lose this autocompletion feature\n@return true, if this field was actually attached","static":false,"name":"detachFrom","comment":"Deprive the given field of this autocompleter.","params":[{"type_long":"javax.swing.JTextField","name":"field","comment":"the field that will lose this autocompletion feature","type_short":"JTextField"}],"throws":[],"return":{"type_long":"boolean","comment":"true, if this field was actually attached","type_short":"boolean"}},{"javadoc":"Register the given auto-completion listener\n@param l the listener to register","static":false,"name":"addAutocompletionListener","comment":"Register the given auto-completion listener","params":[{"type_long":"docking.widgets.autocomplete.AutocompletionListener<T>","name":"l","comment":"the listener to register","type_short":"AutocompletionListener"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Unregister the given auto-completion listener\n@param l the listener to unregister","static":false,"name":"removeAutocompletionListener","comment":"Unregister the given auto-completion listener","params":[{"type_long":"docking.widgets.autocomplete.AutocompletionListener<T>","name":"l","comment":"the listener to unregister","type_short":"AutocompletionListener"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Get all the registered auto-completion listeners\n@return an array of registered listeners","static":false,"name":"getAutocompletionListeners","comment":"Get all the registered auto-completion listeners","params":[],"throws":[],"return":{"type_long":"docking.widgets.autocomplete.AutocompletionListener<T>[]","comment":"an array of registered listeners","type_short":"docking.widgets.autocomplete.AutocompletionListener<T>[]"}},{"javadoc":"Get all registered listeners of the given type\n@param listenerType the type of listeners to get\n@return an array of registered listeners","static":false,"name":"getListeners","comment":"Get all registered listeners of the given type","params":[{"type_long":"java.lang.Class<T>","name":"listenerType","comment":"the type of listeners to get","type_short":"Class"}],"throws":[],"return":{"type_long":"T[]","comment":"an array of registered listeners","type_short":"T[]"}},{"javadoc":"Starts the autocompleter on the given text field.\n \n First, this repeatedly attempts auto-activation. When there are many suggestions, or when\n auto-activation is prevented (see {@link #getCompletionCanDefault(T)}), a list is displayed\n (usually below the caret) containing the suggestions given the fields current contents. The\n list remains open until either the user cancels it (usually via ESC) or the user activates\n a suggestion.\n@note The text field must already be attached.\n@param field the field on which to start autocompletion.","static":false,"name":"startCompletion","comment":"Starts the autocompleter on the given text field.\n \n First, this repeatedly attempts auto-activation. When there are many suggestions, or when\n auto-activation is prevented (see #getCompletionCanDefault(T)), a list is displayed\n (usually below the caret) containing the suggestions given the fields current contents. The\n list remains open until either the user cancels it (usually via ESC) or the user activates\n a suggestion.","params":[{"type_long":"javax.swing.JTextField","name":"field","comment":"the field on which to start autocompletion.","type_short":"JTextField"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}}],"name":"TextFieldAutocompleter","comment":"An autocompleter that may be attached to one or more JTextField.\n \n Each autocompleter instance has one associated window (displaying the list of suggestions) and\n one associated model (generating the list of suggestions). Thus, the list can only be active on\n one of the attached text fields at a time. This is usually the desired behavior, and it allows\n for one autocompleter to be reused on many fields. Behavior is undefined when multiple\n autocompleters are attached to the same text field. More likely, you should implement a\n composite model if you wish to present completions from multiple models on a single text field.\n \n By default, the autocompleter is activated when the user presses CTRL-SPACE, at which point, the\n model is queried for possible suggestions. The completer gives the model all the text preceding\n the current field's caret. This behavior can be changed by overriding the\n #getPrefix(JTextField) method. This may be useful, e.g., to obtain a prefix for\n the current word, rather than the full field contents, preceding the caret. The list is\n displayed such that its top-left corner is placed directly under the current field's caret. As\n the user continues typing, the suggestions are re-computed, and the list tracks with the caret.\n This positioning behavior can be modified by overriding the\n #getCompletionWindowPosition() method. As a convenience, the\n #getCaretPositionOnScreen(JTextField) method is available to compute the default\n position.\n \n Whether or not the list is currently displayed, when the user presses CTRL-SPACE, if only one\n completion is possible, it is automatically activated. This logic is applied again and again,\n until either no suggestions are given, or more than one suggestion is given (or until the\n autocompleter detects an infinite loop). This behavior can by modified on an item-by-item basis\n by overriding the #getCompletionCanDefault(T) method. This same behavior can be\n activated by calling the #startCompletion(JTextField) method, which may be useful, e.g.,\n to bind a different key sequence to start autocompletion.\n \n The appearance of each item in the suggestion list can be modified by overriding the various\n  methods. Note that it's possible for an item to be displayed one way,\n but cause the insertion of different text. In any case, it is best to ensure any modification\n produces an intuitive behavior.\n \n The simplest use case is to create a text field, create an autocompleter with a custom model,\n and then attach and show.\n \n ","fields":[]}
