{"implements":[],"javadoc":"","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"","static":false,"name":"<init>","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns a column object that is usable by the given model.\n <p>\n Dynamic columns and models work on row types.  This method allows clients to use columns\n with row types that differ from the model's row type, as long as a suitable mapper can\n be found.  If no mapper can be found, then an IllegalArgumentException is thrown.  Also,\n if the given column is of the correct type, then that column is returned.\n@param <ROW_TYPE> the <b>model's<\/b> row type\n@param <COLUMN_TYPE> the <b>model's<\/b> row type\n@param model the table model for which a column is needed\n@param column the column that you want to use with the given model\n@return a column object that is usable by the given model.\n@throws IllegalArgumentException if this method cannot figure out how to map the given\n         column's row type to the given model's row type.","static":true,"name":"adaptColumForModel","comment":"Returns a column object that is usable by the given model.\n \n Dynamic columns and models work on row types.  This method allows clients to use columns\n with row types that differ from the model's row type, as long as a suitable mapper can\n be found.  If no mapper can be found, then an IllegalArgumentException is thrown.  Also,\n if the given column is of the correct type, then that column is returned.","params":[{"type_long":"docking.widgets.table.GDynamicColumnTableModel<ROW_TYPE,COLUMN_TYPE>","name":"model","comment":"the table model for which a column is needed","type_short":"GDynamicColumnTableModel"},{"type_long":"docking.widgets.table.AbstractDynamicTableColumn<?,?,?>","name":"column","comment":"the column that you want to use with the given model","type_short":"AbstractDynamicTableColumn"}],"throws":[],"return":{"type_long":"docking.widgets.table.DynamicTableColumn<ROW_TYPE,COLUMN_TYPE,DATA_SOURCE>","comment":"a column object that is usable by the given model.","type_short":"DynamicTableColumn"}},{"javadoc":"Returns all \"discovered\" {@link AbstractDynamicTableColumn} classes that are compatible with the\n given class, which represents the object for a table's row.  For example, many tables use\n <tt>Address<\/tt> as the row type.  In this case, passing <tt>Address.class<\/tt> as the\n parameter to this method will return all {@link AbstractDynamicTableColumn}s that can provide column\n data by working with <tt>Address<\/tt> instances.\n \n <p><u>Usage Notes:<\/u>  This class will not only discover {@link AbstractDynamicTableColumn}s\n that directly support the given class type, but will also use discovered\n {@link TableRowMapper} objects to create adapters that allow the\n use of table row data that does not exactly match the supported type of discovered\n {@link AbstractDynamicTableColumn} classes.  For example, suppose that a table's row type is\n <tt>Address<\/tt>.  This methods will return at least all {@link AbstractDynamicTableColumn}s\n that support <tt>Address<\/tt> data.  In order to support extra columns, Ghidra has\n created a {@link TableRowMapper} that can convert a <tt>ProgramLocation<\/tt> into an\n <tt>Address<\/tt>.  This method will find and use this mapper to return a\n {@link MappedTableColumn} instance (which is an {@link AbstractDynamicTableColumn}).  By doing\n this, any table that has <tt>Address<\/tt> objects as its row type can now use\n {@link AbstractDynamicTableColumn}s that support <tt>ProgramLocations<\/tt> in addition to\n <tt>Address<\/tt> objects.  These mappers provide a way for tables that have non-standard\n Ghidra data as their row type to take advantage of existing dynamic columns for standard\n Ghidra data (like ProgramLocations and Addresses).\n@param rowTypeClass table's row type\n@return the discovered column","static":true,"name":"getDynamicTableColumns","comment":"Returns all \"discovered\" AbstractDynamicTableColumn classes that are compatible with the\n given class, which represents the object for a table's row.  For example, many tables use\n Address as the row type.  In this case, passing Address.class as the\n parameter to this method will return all AbstractDynamicTableColumns that can provide column\n data by working with Address instances.\n \n Usage Notes:  This class will not only discover AbstractDynamicTableColumns\n that directly support the given class type, but will also use discovered\n TableRowMapper objects to create adapters that allow the\n use of table row data that does not exactly match the supported type of discovered\n AbstractDynamicTableColumn classes.  For example, suppose that a table's row type is\n Address.  This methods will return at least all AbstractDynamicTableColumns\n that support Address data.  In order to support extra columns, Ghidra has\n created a TableRowMapper that can convert a ProgramLocation into an\n Address.  This method will find and use this mapper to return a\n MappedTableColumn instance (which is an AbstractDynamicTableColumn).  By doing\n this, any table that has Address objects as its row type can now use\n AbstractDynamicTableColumns that support ProgramLocations in addition to\n Address objects.  These mappers provide a way for tables that have non-standard\n Ghidra data as their row type to take advantage of existing dynamic columns for standard\n Ghidra data (like ProgramLocations and Addresses).","params":[{"type_long":"java.lang.Class<ROW_TYPE>","name":"rowTypeClass","comment":"table's row type","type_short":"Class"}],"throws":[],"return":{"type_long":"java.util.Collection<docking.widgets.table.DynamicTableColumn<ROW_TYPE,?,?>>","comment":"the discovered column","type_short":"Collection"}},{"javadoc":"Returns a list of all the {@link ColumnConstraint} that are capable of filtering the\n destination type of the given mapper.  The mapper will be used to create a mapped constraint\n that will be called with an instance of the type <code>T<\/code>.\n@param mapper the mapper that will be used to convert\n@return a list of all the {@link ColumnConstraint} that are capable of filtering the\n \t\t   given column type","static":true,"name":"getColumnConstraints","comment":"Returns a list of all the ColumnConstraint that are capable of filtering the\n destination type of the given mapper.  The mapper will be used to create a mapped constraint\n that will be called with an instance of the type T.","params":[{"type_long":"docking.widgets.table.constraint.ColumnTypeMapper<T,M>","name":"mapper","comment":"the mapper that will be used to convert","type_short":"ColumnTypeMapper"}],"throws":[],"return":{"type_long":"java.util.Collection<docking.widgets.table.constraint.ColumnConstraint<T>>","comment":"a list of all the ColumnConstraint that are capable of filtering the\n \t\t   given column type","type_short":"Collection"}},{"javadoc":"Returns a list of all the {@link ColumnConstraint} that are capable of filtering the\n given column type.\n@param columnType the class of the data that is return by the table model for specific column.\n@return a list of all the {@link ColumnConstraint} that are capable of filtering the\n given column type.","static":true,"name":"getColumnConstraints","comment":"Returns a list of all the ColumnConstraint that are capable of filtering the\n given column type.","params":[{"type_long":"java.lang.Class<T>","name":"columnType","comment":"the class of the data that is return by the table model for specific column.","type_short":"Class"}],"throws":[],"return":{"type_long":"java.util.Collection<docking.widgets.table.constraint.ColumnConstraint<T>>","comment":"a list of all the ColumnConstraint that are capable of filtering the\n given column type.","type_short":"Collection"}}],"name":"DiscoverableTableUtils","comment":"","fields":[]}
