{"implements":["docking.widgets.table.SortListener"],"javadoc":"A class to keep track of and persist state for column models, including size, ordering and\n visibility.\n <p>\n This class performs a bit of magic to accomplish its goals.  Resultingly, some of the code\n herein may seem a bit odd or of poor quality.  These rough spots are documented as best as\n possible.\n <p>\n The basic outline of how this class works:<br>\n \n This class loads and save table column state via requests made by clients like the {@link GTable} or\n the {@link GTableColumnModel}.  These requests are in response to direct users actions (like\n showing a new column) or to table changes (like column resizing).  There are few things that \n make this code tricky.  Namely, when a change notification comes from the subsystem and not \n direct user intervention, we do not know if the change was motived by the user directly or \n by programmatic table configuration.  We would prefer to only save data when the user makes \n changes, but we can not always know the source of the change.  For example, column resizing\n can happen due to user dragging or due to the table subsystem performing a column layout.\n <p>\n To facilitate this magic, we listen to all changes, attempting to: 1) ignore those that we know\n are not from the user, and 2) buffer the changes so that they are not excessive and so they\n happen in the correct order.\n <p>\n For 1, we ignore all changes until the table has been shown for the first time.  For 2, we use\n SwingUpdate managers.\n <p>\n The complicated part is that we allow clients to add columns at any time.  If they do so \n after the table has been made visible, then we cannot ignore the event like we do when the\n table has not yet been realized.  In our world view, the uniqueness of a table is based upon\n it's class and its columns.  Thus, when a column is added or removed, it becomes a different\n table and thus, saved settings must be applied.","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"","static":false,"name":"modelSorted","comment":"","params":[{"type_long":"docking.widgets.table.TableSortState","name":"sortState","comment":"","type_short":"TableSortState"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}}],"name":"TableColumnModelState","comment":"A class to keep track of and persist state for column models, including size, ordering and\n visibility.\n \n This class performs a bit of magic to accomplish its goals.  Resultingly, some of the code\n herein may seem a bit odd or of poor quality.  These rough spots are documented as best as\n possible.\n \n The basic outline of how this class works:\n \n This class loads and save table column state via requests made by clients like the GTable or\n the GTableColumnModel.  These requests are in response to direct users actions (like\n showing a new column) or to table changes (like column resizing).  There are few things that \n make this code tricky.  Namely, when a change notification comes from the subsystem and not \n direct user intervention, we do not know if the change was motived by the user directly or \n by programmatic table configuration.  We would prefer to only save data when the user makes \n changes, but we can not always know the source of the change.  For example, column resizing\n can happen due to user dragging or due to the table subsystem performing a column layout.\n \n To facilitate this magic, we listen to all changes, attempting to: 1) ignore those that we know\n are not from the user, and 2) buffer the changes so that they are not excessive and so they\n happen in the correct order.\n \n For 1, we ignore all changes until the table has been shown for the first time.  For 2, we use\n SwingUpdate managers.\n \n The complicated part is that we allow clients to add columns at any time.  If they do so \n after the table has been made visible, then we cannot ignore the event like we do when the\n table has not yet been realized.  In our world view, the uniqueness of a table is based upon\n it's class and its columns.  Thus, when a column is added or removed, it becomes a different\n table and thus, saved settings must be applied.","fields":[]}
