{"implements":["db.Buffer"],"javadoc":"<code>DBBuffer<\/code> provides storage for large data objects utilizing a common\n buffer management system.  Smaller data buffers are allocated and chained as needed.\n All instances of DBBuffer must be immediately discarded following an undo or redo on the \n associated DBHandle.\n <p>\n The largest supported chained buffer is about 2-GBytes.  This limit may be slightly smaller \n based upon the underlying database buffer size.\n <p>\n The buffer may consist of either a single Data Node or a series of Index Nodes \n which reference Data Nodes.\n <pre>\n Data Node (Non-indexed):\n   | 9 (1) | Obfuscation\/DataLength(4) | Data ...\n \n Data Node (Indexed):\n   | 9 (1) | Data ...\n \n Index Node:\n   | 8 (1) | Obfuscation\/DataLength(4) | NextIndexId(4) | DataBuffer1Id(4) | ... | DataBufferNId(4) |\n   Number of index entries computed based upon data length and buffer size.  The index for \n   the entire data space is divided among a series of Index Nodes which\n   are chained together using the NextIndexId field. Each Index Node identifies \n   Data Nodes which have been allocated by a DataBufferId.  A DataBufferId of -1 indicates an\n   non-allocated data node.  The DataLength field is only used in the first index buffer.\n   \n Obfuscation:\n   Data obfuscation is indicated by a '1' in the most-significant bit of the Obfuscation\/DataLength \n   field.\n <\/pre>\n Once a DBBuffer is deleted or appended to another DBBuffer, it becomes invalid and \n may no longer be used.","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"Construct a new chained buffer with optional obfuscation and uninitialized data source.\n This method may only be invoked while a database transaction \n is in progress.\n@param size buffer size\n@param enableObfuscation true to enable xor-ing of stored data to facilitate data obfuscation.\n@param uninitializedDataSource optional data source for uninitialized data.  This should be a \n read-only buffer which will always be used when re-instantiating the same stored ChainedBuffer.\n This should not be specified if buffer will be completely filled\/initialized.\n@param unintializedDataSourceOffset uninitialized data source offset which corresponds to\n this buffers contents.\n@param bufferMgr database buffer manager\n@throws IOException","static":false,"name":"<init>","comment":"Construct a new chained buffer with optional obfuscation and uninitialized data source.\n This method may only be invoked while a database transaction \n is in progress.","params":[{"type_long":"int","name":"size","comment":"buffer size","type_short":"int"},{"type_long":"boolean","name":"enableObfuscation","comment":"true to enable xor-ing of stored data to facilitate data obfuscation.","type_short":"boolean"},{"type_long":"db.Buffer","name":"uninitializedDataSource","comment":"optional data source for uninitialized data.  This should be a \n read-only buffer which will always be used when re-instantiating the same stored ChainedBuffer.\n This should not be specified if buffer will be completely filled\/initialized.","type_short":"Buffer"},{"type_long":"int","name":"unintializedDataSourceOffset","comment":"uninitialized data source offset which corresponds to\n this buffers contents.","type_short":"int"},{"type_long":"db.buffers.BufferMgr","name":"bufferMgr","comment":"database buffer manager","type_short":"BufferMgr"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Construct a new chained buffer with optional obfuscation.\n This method may only be invoked while a database transaction \n is in progress.\n@param size buffer size\n@param enableObfuscation true to enable xor-ing of stored data to facilitate data obfuscation.\n@param bufferMgr database buffer manager\n@throws IOException","static":false,"name":"<init>","comment":"Construct a new chained buffer with optional obfuscation.\n This method may only be invoked while a database transaction \n is in progress.","params":[{"type_long":"int","name":"size","comment":"buffer size","type_short":"int"},{"type_long":"boolean","name":"enableObfuscation","comment":"true to enable xor-ing of stored data to facilitate data obfuscation.","type_short":"boolean"},{"type_long":"db.buffers.BufferMgr","name":"bufferMgr","comment":"database buffer manager","type_short":"BufferMgr"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Construct a new chained buffer.\n This method may only be invoked while a database transaction is in progress.\n@param size buffer size\n@param bufferMgr database buffer manager\n@throws IOException","static":false,"name":"<init>","comment":"Construct a new chained buffer.\n This method may only be invoked while a database transaction is in progress.","params":[{"type_long":"int","name":"size","comment":"buffer size","type_short":"int"},{"type_long":"db.buffers.BufferMgr","name":"bufferMgr","comment":"database buffer manager","type_short":"BufferMgr"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Construct an existing chained buffer.\n@param bufferMgr database buffer manager\n@param bufferId database buffer ID which corresponds to a stored ChainedBuffer\n@param uninitializedDataSource optional data source for uninitialized data.  This should be a \n read-only buffer which will always be used when re-instantiating the same stored ChainedBuffer.\n This should not be specified if buffer will be completely filled\/initialized.\n@param unintializedDataSourceOffset uninitialized data source offset which corresponds to\n this buffers contents.\n@throws IOException","static":false,"name":"<init>","comment":"Construct an existing chained buffer.","params":[{"type_long":"db.buffers.BufferMgr","name":"bufferMgr","comment":"database buffer manager","type_short":"BufferMgr"},{"type_long":"int","name":"bufferId","comment":"database buffer ID which corresponds to a stored ChainedBuffer","type_short":"int"},{"type_long":"db.Buffer","name":"uninitializedDataSource","comment":"optional data source for uninitialized data.  This should be a \n read-only buffer which will always be used when re-instantiating the same stored ChainedBuffer.\n This should not be specified if buffer will be completely filled\/initialized.","type_short":"Buffer"},{"type_long":"int","name":"unintializedDataSourceOffset","comment":"uninitialized data source offset which corresponds to\n this buffers contents.","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Construct an existing chained buffer.\n@param bufferMgr database buffer manager\n@param bufferId database buffer ID which corresponds to a stored ChainedBuffer","static":false,"name":"<init>","comment":"Construct an existing chained buffer.","params":[{"type_long":"db.buffers.BufferMgr","name":"bufferMgr","comment":"database buffer manager","type_short":"BufferMgr"},{"type_long":"int","name":"bufferId","comment":"database buffer ID which corresponds to a stored ChainedBuffer","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"@return true if obfuscated data storage has been enabled","static":false,"name":"hasObfuscatedStorage","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if obfuscated data storage has been enabled","type_short":"boolean"}},{"javadoc":"Set the read-only state of this ChainedBuffer.  After invoking this method any\n attempt to alter this buffer will result in an UnsupportedOperation exception.","static":false,"name":"setReadOnly","comment":"Set the read-only state of this ChainedBuffer.  After invoking this method any\n attempt to alter this buffer will result in an UnsupportedOperation exception.","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Set the new size for this DBBuffer object.\n@param size new size\n@param preserveData if true, existing data is preserved at the original offsets.  If false,\n no additional effort will be expended to preserve data.\n@throws UnsupportedOperationException thrown if this ChainedBuffer utilizes an \n Uninitialized Data Source or is read-only\n@throws IOException thrown if an IO error occurs.\n@throws UnsupportedOperationException if read-only or uninitialized data source is used","static":false,"name":"setSize","comment":"Set the new size for this DBBuffer object.","params":[{"type_long":"int","name":"size","comment":"new size","type_short":"int"},{"type_long":"boolean","name":"preserveData","comment":"if true, existing data is preserved at the original offsets.  If false,\n no additional effort will be expended to preserve data.","type_short":"boolean"}],"throws":[{"type_long":"java.io.IOException","comment":"thrown if an IO error occurs.","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Split this DBBuffer object into two separate DBBuffers.  This DBBuffer remains\n valid but its new size is equal offset.  The newly created DBBuffer is \n returned.\n@param offset the split point.  The byte at this offset becomes the first\n byte within the new buffer.\n@return the new DBBuffer object.\n@throws UnsupportedOperationException thrown if this ChainedBuffer is read-only\n@throws ArrayIndexOutOfBoundsException if offset is invalid.\n@throws IOException thrown if an IO error occurs","static":false,"name":"split","comment":"Split this DBBuffer object into two separate DBBuffers.  This DBBuffer remains\n valid but its new size is equal offset.  The newly created DBBuffer is \n returned.","params":[{"type_long":"int","name":"offset","comment":"the split point.  The byte at this offset becomes the first\n byte within the new buffer.","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"thrown if an IO error occurs","type_short":"IOException"}],"return":{"type_long":"db.ChainedBuffer","comment":"the new DBBuffer object.","type_short":"ChainedBuffer"}},{"javadoc":"Append the contents of the specified dbBuf onto the end of this buffer.\n The size of this buffer increases by the size of dbBuf.  When the operation \n is complete, dbBuf object is no longer valid and must not be used.\n@param dbBuf the buffer to be appended to this buffer.\n@throws IOException thrown if an IO error occurs\n@throws UnsupportedOperationException if read-only, uninitialized data source is used,\n or both buffers do not have the same obfuscation enablement","static":false,"name":"append","comment":"Append the contents of the specified dbBuf onto the end of this buffer.\n The size of this buffer increases by the size of dbBuf.  When the operation \n is complete, dbBuf object is no longer valid and must not be used.","params":[{"type_long":"db.ChainedBuffer","name":"dbBuf","comment":"the buffer to be appended to this buffer.","type_short":"ChainedBuffer"}],"throws":[{"type_long":"java.io.IOException","comment":"thrown if an IO error occurs","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Get the first buffer ID associated with this chained buffer.  This DBBuffer\n may be reinstatiated using the returned buffer ID provided subsequent changes \n are not made.\n@return buffer ID","static":false,"name":"getId","comment":"Get the first buffer ID associated with this chained buffer.  This DBBuffer\n may be reinstatiated using the returned buffer ID provided subsequent changes \n are not made.","params":[],"throws":[],"return":{"type_long":"int","comment":"buffer ID","type_short":"int"}},{"javadoc":"Delete and release all underlying DataBuffers.","static":false,"name":"delete","comment":"Delete and release all underlying DataBuffers.","params":[],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"get","comment":"","params":[{"type_long":"int","name":"offset","comment":"","type_short":"int"},{"type_long":"byte[]","name":"data","comment":"","type_short":"byte[]"},{"type_long":"int","name":"dataOffset","comment":"","type_short":"int"},{"type_long":"int","name":"length","comment":"","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"get","comment":"","params":[{"type_long":"int","name":"offset","comment":"","type_short":"int"},{"type_long":"byte[]","name":"data","comment":"","type_short":"byte[]"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"get","comment":"","params":[{"type_long":"int","name":"offset","comment":"","type_short":"int"},{"type_long":"int","name":"length","comment":"","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"byte[]","comment":"","type_short":"byte[]"}},{"javadoc":"","static":false,"name":"getByte","comment":"","params":[{"type_long":"int","name":"offset","comment":"","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"byte","comment":"","type_short":"byte"}},{"javadoc":"","static":false,"name":"getInt","comment":"","params":[{"type_long":"int","name":"offset","comment":"","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"","static":false,"name":"getLong","comment":"","params":[{"type_long":"int","name":"offset","comment":"","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"long","comment":"","type_short":"long"}},{"javadoc":"","static":false,"name":"getShort","comment":"","params":[{"type_long":"int","name":"offset","comment":"","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"short","comment":"","type_short":"short"}},{"javadoc":"","static":false,"name":"length","comment":"","params":[],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"Fill the buffer over the specified range with a byte value.\n@param startOffset starting offset, inclusive\n@param endOffset ending offset, exclusive\n@param fillByte byte value","static":false,"name":"fill","comment":"Fill the buffer over the specified range with a byte value.","params":[{"type_long":"int","name":"startOffset","comment":"starting offset, inclusive","type_short":"int"},{"type_long":"int","name":"endOffset","comment":"ending offset, exclusive","type_short":"int"},{"type_long":"byte","name":"fillByte","comment":"byte value","type_short":"byte"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Fill buffer with data provided by InputStream.  If \n stream is exhausted, the remainder of the buffer will be filled\n with 0's.\n@param in data source\n@throws IOException thrown if IO error occurs.","static":false,"name":"fill","comment":"Fill buffer with data provided by InputStream.  If \n stream is exhausted, the remainder of the buffer will be filled\n with 0's.","params":[{"type_long":"java.io.InputStream","name":"in","comment":"data source","type_short":"InputStream"}],"throws":[{"type_long":"java.io.IOException","comment":"thrown if IO error occurs.","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"put","comment":"","params":[{"type_long":"int","name":"offset","comment":"","type_short":"int"},{"type_long":"byte[]","name":"data","comment":"","type_short":"byte[]"},{"type_long":"int","name":"dataOffset","comment":"","type_short":"int"},{"type_long":"int","name":"length","comment":"","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"","static":false,"name":"put","comment":"","params":[{"type_long":"int","name":"offset","comment":"","type_short":"int"},{"type_long":"byte[]","name":"bytes","comment":"","type_short":"byte[]"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"","static":false,"name":"putByte","comment":"","params":[{"type_long":"int","name":"offset","comment":"","type_short":"int"},{"type_long":"byte","name":"b","comment":"","type_short":"byte"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"","static":false,"name":"putInt","comment":"","params":[{"type_long":"int","name":"offset","comment":"","type_short":"int"},{"type_long":"int","name":"v","comment":"","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"","static":false,"name":"putLong","comment":"","params":[{"type_long":"int","name":"offset","comment":"","type_short":"int"},{"type_long":"long","name":"v","comment":"","type_short":"long"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"","static":false,"name":"putShort","comment":"","params":[{"type_long":"int","name":"offset","comment":"","type_short":"int"},{"type_long":"short","name":"v","comment":"","type_short":"short"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"int","comment":"","type_short":"int"}}],"name":"ChainedBuffer","comment":"DBBuffer provides storage for large data objects utilizing a common\n buffer management system.  Smaller data buffers are allocated and chained as needed.\n All instances of DBBuffer must be immediately discarded following an undo or redo on the \n associated DBHandle.\n \n The largest supported chained buffer is about 2-GBytes.  This limit may be slightly smaller \n based upon the underlying database buffer size.\n \n The buffer may consist of either a single Data Node or a series of Index Nodes \n which reference Data Nodes.\n \n Data Node (Non-indexed):\n   | 9 (1) | Obfuscation\/DataLength(4) | Data ...\n \n Data Node (Indexed):\n   | 9 (1) | Data ...\n \n Index Node:\n   | 8 (1) | Obfuscation\/DataLength(4) | NextIndexId(4) | DataBuffer1Id(4) | ... | DataBufferNId(4) |\n   Number of index entries computed based upon data length and buffer size.  The index for \n   the entire data space is divided among a series of Index Nodes which\n   are chained together using the NextIndexId field. Each Index Node identifies \n   Data Nodes which have been allocated by a DataBufferId.  A DataBufferId of -1 indicates an\n   non-allocated data node.  The DataLength field is only used in the first index buffer.\n   \n Obfuscation:\n   Data obfuscation is indicated by a '1' in the most-significant bit of the Obfuscation\/DataLength \n   field.\n \n Once a DBBuffer is deleted or appended to another DBBuffer, it becomes invalid and \n may no longer be used.","fields":[]}
